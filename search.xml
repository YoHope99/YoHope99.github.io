<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Docker的安装以及解决启动失败问题]]></title>
    <url>%2F2019%2F07%2F28%2FDocker%E7%9A%84%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言 本文章主要讲解在Linux虚拟机上安装Docker以及安装后启动失败的问题。 在Linux虚拟机上安装Docker以及解决启动问题步骤： 检查Linux系统内核版本，必须是3.10及以上uname -r 安装docker，yum install docker，输入y确定安装，知道出现Complete!表示安装已经完成 启动docker，systemctl start docker，发现启动不了 输入systemctl status docker.service命令会发现提示以下错误提示 错误信息表示： 此linux的内核中的SELinux不支持 overlay2 graph driver ，解决方法有两个，要么启动一个新内核，要么就在docker里禁用selinux，–selinux-enabled=false； 解决方案： 用vi编辑器打开docker配置文件，修改配置信息，在–selinux-enabled后面添加=false，如下： 输入systemctl start docker命令，重新启动发现可以正常启动了。 设置虚拟机开机启动docker12[root@localhost ~]# systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有趣的二进制问题]]></title>
    <url>%2F2019%2F07%2F25%2F%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于最近在忙其他事情而导致一周多没有写博客了，趁今天下午有空，也想起了一个之前看到的有趣的二进制问题，所以这次博文就探讨一下这个有趣的问题。 题目&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有1000瓶水，其中999瓶没有毒药，只有1瓶有毒药，只要一喝到毒药就会在一天后死亡，给你10个老鼠和1天的时间，问你怎样在规定的条件内快速找到哪一瓶水含有毒药？ 解决方案 对1000瓶水贴上二进制编号（10位）： 1号 ———–0000000001 2号 ———–0000000010 3号 ———–0000000011 …………………………………… 999号 ——–1111100111 ​ 1000号 ——–1111101000 对10只老鼠进行编号： 分别是A，B，C，D，E，F，G，H，I，J 让A~J老鼠分别喝同一列编码是1的水，即： A老鼠喝编码格式为xxxxxxxxx1的水 B老鼠喝编码格式为xxxxxxxx1x的水 C老鼠喝编码格式为xxxxxxx1xx的水 D老鼠喝编码格式为xxxxxx1xxx的水 E老鼠喝编码格式为xxxxx1xxxx的水 F老鼠喝编码格式为xxxx1xxxxx的水 G老鼠喝编码格式为xxx1xxxxxx的水 H老鼠喝编码格式为xx1xxxxxxx的水 I老鼠喝编码格式为x1xxxxxxxx的水 J老鼠和编码格式为1xxxxxxxxx的水 假如A，D，I老鼠死了，那个该水含有毒药的编号就是0100001001，化为10进制为265号。 小结以上就是一个二进制比较有趣的问题。]]></content>
      <categories>
        <category>二进制</category>
      </categories>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中Bean的装配方式]]></title>
    <url>%2F2019%2F07%2F17%2FSpring%E4%B8%ADBean%E7%9A%84%E8%A3%85%E9%85%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bean的装配可以理解为依赖关系注入，Bean的装配方式即Bean依赖注入的方式。Spring容器支持多种形式的Bean的装配方式，如基于XML的装配、基于注解（Annotation）的装配和自动装配（其中最常用的是基于注解的装配），本文章将主要讲解着三种装配方式的使用。 基于XML的装配 方式一：设置注入 条件：①Bean类必须有一个无参构造方法；②Bean类必须为属性提供setter方法。 在配置文件中，使用元素来为每个属性注入值 方式二：构造注入 条件：Bean类必须提供有参构造方法 在配置文件中，使用元素来为参数注入值 具体实现步骤如下 创建Java类User，提供有参、无参构造方法以及属性setter方法； 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.ssm.assemble;import java.util.List;public class User &#123; private String username; private Integer password; private List&lt;String&gt; list; /** * 1.使用构造注入 * 1.1提供带所有参数的有参构造方法。 */ public User(String username, Integer password, List&lt;String&gt; list) &#123; super(); this.username = username; this.password = password; this.list = list; &#125; /** * 2.使用设值注入 * 2.1提供默认空参构造方法 ; * 2.2为所有属性提供setter方法。 */ public User() &#123; super(); &#125; public void setUsername(String username) &#123; this.username = username; &#125; public void setPassword(Integer password) &#123; this.password = password; &#125; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125; @Override public String toString() &#123; return &quot;User [username=&quot; + username + &quot;, password=&quot; + password + &quot;, list=&quot; + list + &quot;]&quot;; &#125;&#125; 创建Spring配置文件beans1.xml，使用以上两种方式装配Bean; 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd&quot;&gt; &lt;!--1.使用构造注入方式装配User实例 --&gt; &lt;bean id=&quot;user1&quot; class=&quot;com.ssm.assemble.User&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;小红&quot; /&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;987654&quot; /&gt; &lt;constructor-arg index=&quot;2&quot;&gt; &lt;list&gt; &lt;value&gt;&quot;constructorvalue1&quot;&lt;/value&gt; &lt;value&gt;&quot;constructorvalue2&quot;&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!--2.使用设值注入方式装配User实例 --&gt; &lt;bean id=&quot;user2&quot; class=&quot;com.ssm.assemble.User&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;小明&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt; &lt;!-- 注入list集合 --&gt; &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;&quot;setlistvalue1&quot;&lt;/value&gt; &lt;value&gt;&quot;setlistvalue2&quot;&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 创建测试类XmlBeanAssembleTest，测试程序； 12345678910111213141516package com.ssm.assemble;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class XmlBeanAssembleTest &#123; public static void main(String[] args) &#123; // 定义配置文件路径 String xmlPath = &quot;beans1.xml&quot;; // 加载配置文件 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath); // 构造方式输出结果 System.out.println(applicationContext.getBean(&quot;user1&quot;)); // 设值方式输出结果 System.out.println(applicationContext.getBean(&quot;user2&quot;)); &#125;&#125; 运行效果。 基于注解的装配 由于基于XML的装配可能会导致XML配置文件过于臃肿，给后续的维护和升级带来一定的困难。因此，Spring提供了对Annotation（注解）技术的全面支持。 具体实现步骤如下 创建数据访问（Dao）层接口UserDao； 12345package com.ssm.annotation;public interface UserDao &#123; public void save();&#125; 创建数据访问（UserDao）层接口的实现类UserDaoImpl，并且在实现类前添加对应的注解@Repository(“userDao”)； 123456789101112package com.ssm.annotation;import org.springframework.stereotype.Repository;@Repository(&quot;userDao&quot;)//@Repository(&quot;userDao&quot;)相当于配置文件中的:&lt;bean id=&quot;userDao&quot; class=&quot;com.ssm.annotation.UserDaoImpl&quot; /&gt;public class UserDaoImpl implements UserDao&#123; @Override public void save() &#123; System.out.println(&quot;userdao...save...&quot;); &#125;&#125; 创建业务（Service）层接口UserService； 12345package com.ssm.annotation;public interface UserService &#123; public void save();&#125; 创建业务（Service）层接口的实现类UserServiceImpl并添加属性对象UserDao的setter方法，并在实现类前添加对应的注解@Service(“userService”)和在类里面方法前添加对应的注解 @Resource(name=”userDao”)； 1234567891011121314151617181920212223package com.ssm.annotation;import javax.annotation.Resource;import org.springframework.stereotype.Service;@Service(&quot;userService&quot;)//相当于配置文件中的:&lt;bean id=&quot;userService&quot; class=&quot;com.ssm.annotation.UserServiceImpl&quot; /&gt;public class UserServiceImpl implements UserService&#123; @Resource(name=&quot;userDao&quot;) //当于配置文件中的:&lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; private UserDao userDao; public void save() &#123; //调用userDao中的save方法 this.userDao.save(); System.out.println(&quot;userservice....save...&quot;); &#125; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125;&#125; 创建控制（Controller）层Java类UserController，并在实现类前添加对应的注解@Controller(“userController”)和在类里面方法前添加对应的注解 @Resource(name=”userService”)； 123456789101112131415161718192021package com.ssm.annotation;import javax.annotation.Resource;import org.springframework.stereotype.Controller;@Controller(&quot;userController&quot;)//相当于配置文件中的:&lt;bean id=&quot;userController&quot; class=&quot;com.ssm.annotation.UserController&quot; /&gt;public class UserController &#123; @Resource(name=&quot;userService&quot;) //当于配置文件中的:&lt;property name=&quot;userService&quot; ref=&quot;userService&quot;/&gt; private UserService userService; public void save()&#123; this.userService.save(); System.out.println(&quot;userController...save...&quot;); &#125; public void setUserService(UserService userService) &#123; this.userService = userService; &#125;&#125; 创建Spring配置文件beans2.xml，开启注解和定义Bean; 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd&quot;&gt; &lt;!-- 使用 context 命名空间 ,在配置文件中开启相应的注解处理器 --&gt; &lt;context:annotation-config /&gt; &lt;!--分别定义3个Bean实例 --&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.ssm.annotation.UserDaoImpl&quot; /&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.ssm.annotation.UserServiceImpl&quot; /&gt; &lt;bean id=&quot;userController&quot; class=&quot;com.ssm.annotation.UserController&quot; /&gt; &lt;!--使用 context 命名空间 ,通知Spring扫描指定包下所有Bean类，进行注解解析--&gt; &lt;context:component-scan base-package=&quot;com.ssm.annotation&quot; /&gt;&lt;/beans&gt; 创建测试类AnnotationAssembleTest，测试程序； 123456789101112131415package com.ssm.annotation;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class AnnotationAssembleTest &#123; public static void main(String[] args) &#123; // 定义配置文件路径 String xmlPath = &quot;beans2.xml&quot;; // 加载配置文件 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath); // 获取UserController实例 UserController userController = (UserController) applicationContext.getBean(&quot;userController&quot;); // 调用UserController中的save()方法 userController.save(); &#125;&#125; 运行效果。 自动装配 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓自动装配，就是将一个Bean自动的注入到到其他Bean的Property中。 Spring的元素中包含一个autowire属性，我们可以通过设置autowire的属性值来自动装配Bean。autowire属性有5个值，其值及说明下表所示： 具体实现步骤如下 这里只需要在基于注解的装配配置文件（beans.xml）中把注解方式换成自动装配即可，具体代码如下： 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd"&gt; &lt;!-- 使用 context 命名空间 ,在配置文件中开启相应的注解处理器 --&gt; &lt;!--&lt;context:annotation-config /&gt;--&gt; &lt;!--&amp;lt;!&amp;ndash;分别定义3个Bean实例 &amp;ndash;&amp;gt;--&gt; &lt;!--&lt;bean id="userDao" class="com.ssm.annotation.UserDaoImpl" /&gt;--&gt; &lt;!--&lt;bean id="userService" class="com.ssm.annotation.UserServiceImpl" /&gt;--&gt; &lt;!--&lt;bean id="userController" class="com.ssm.annotation.UserController" /&gt;--&gt; &lt;!--&amp;lt;!&amp;ndash;使用 context 命名空间 ,通知Spring扫描指定包下所有Bean类，进行注解解析&amp;ndash;&amp;gt;--&gt; &lt;!--&lt;context:component-scan base-package="com.ssm.annotation" /&gt;--&gt; &lt;!-- 使用bean元素的autowire属性完成自动装配 --&gt; &lt;bean id="userDao" class="com.ssm.annotation.UserDaoImpl" /&gt; &lt;bean id="userService" class="com.ssm.annotation.UserServiceImpl" autowire="byName" /&gt; &lt;bean id="userController" class="com.ssm.annotation.UserController" autowire="byName"/&gt;&lt;/beans&gt; 运行效果和基于注解的装配一样 小结 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上就是Spring中Bean的三种装配方式，其中我们需要重点掌握第二种基于注解的装配，它是我们日常工作最常用的一种装配。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Bean的装配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈快速排序]]></title>
    <url>%2F2019%2F07%2F13%2F%E8%B0%88%E8%B0%88%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[前言&nbsp;&nbsp;&nbsp;本文章主要讲解快速排序的原理以及代码实现。 快速排序基于的思想（分治法）分治法的简述&nbsp;&nbsp;&nbsp;&nbsp;分治法是指将一个难以直接解决的大问题，划分成一些规模较小的子问题，以便各个击破，分而治之。 分治法的求解过程分治法求解问题的主要步骤：划分，求解，合并。 （1）问题划分。将规模为n的问题划分成k个子问题； （2）求解子问题。各子问题的求解方法相同，通常采用递归方法实现； （3）合并子问题的解。将各子问题的解逐层合并，得到问题的最终解。 快速排序的分治策略（1）划分：选定一个记录作为轴值，以轴值为基准将整个序列划分为两个子序列r1… ri-1和ri+1 … rn，前一个子 序列中记录的值均小于或等于轴值，后一个子序列中记录的值均大于或等于轴值； （2）求解子问题：分别对划分后的每一个子序列递归处理； （3）合并：由于对子序列r1 … ri-1和ri+1 … rn的排序是就地进行的，所以合并不需要执行任何操作。 举例子说明对序列[23,13,35,6,19,50,28]进行快速排序的过程。（注意：这里以第一个记录作为轴值，黑体代表轴值） 一次划分过程，如下图： 以轴值为基准将待排序序列划分为两个子序列后，对每一个子序列分别递归进行处理，下图是一个快速排序的完整的例子。 算法实现12345678910111213141516171819202122232425262728293031323334 int Partition(int r[ ], int first, int end) &#123; int i=first, j=end; //初始化 int temp; while (i&lt;j) &#123; while (i&lt;j &amp;&amp; r[i]&lt;= r[j]) j--; //右侧扫描 if (i&lt;j) &#123; temp=r[i]; r[i]=r[j]; r[j]=temp; //将较小记录交换到前面 i++; &#125; while (i&lt;j &amp;&amp; r[i]&lt;= r[j]) i++; //左侧扫描 if (i&lt;j) &#123; temp=r[i]; r[i]=r[j]; r[j]=temp; //将较大记录交换到后面 j--; &#125; &#125; return i; // i为轴值记录的最终位置 &#125;void QuickSort(int r[ ], int first, int end) &#123; int mid; //划分后的轴值位置 if (first &lt; end) &#123; mid = Partition(r, first, end); //划分，mid是轴值在序列中的位置 QuickSort(r, first, mid-1); //求解子问题1，对左侧子序列进行快速排序 QuickSort(r, mid+1, end); //求解子问题2，对右侧子序列进行快速排序 &#125;&#125; 快速排序时间复杂度和空间复杂度分析 注意：一个序列基本有序用快速排序反而是不合适的！]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>快速排序</tag>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程单例模式]]></title>
    <url>%2F2019%2F07%2F06%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言这篇文章主要讲述基于Java语言实现多线程的单例模式。 单例模式的概述为什么需要单例模式&emsp;&emsp;&emsp;对于一个软件系统中的某些类而言，只有一个实例很重要，例如一个系统只能有一个窗口管理器或文件系统，一个系统只能有一个集市工具或ID生成器等等。在Windows操作系统中就只能打开一个任务管理器窗口，如下图1所示。如果不使用机智对窗口对象进行唯一化，势必会弹出多个窗口。如果这些窗口显示的内容完全一致，则是重复对象，浪费内存资源；如果这些窗口显示的内容不一致，则意味着在某一瞬间系统有多个状态，与实际不符合，这会给用户带来误解，不知道哪一个才是真实的状态。因此有时确保系统中某个对象的唯一性（即一个类只能有一个实例）非常重要。 单例模式的定义&emsp;&emsp;&emsp;确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。 多线程单例模式的实现基于饿汉式单例实例代码 1234567891011121314151617181920212223242526public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return instance; &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub Singleton s1, s2; s1 = Singleton.getInstance(); s2 = Singleton.getInstance(); if(s1 == s2)&#123; System.out.println("两个对象是相同实例"); &#125; else&#123; System.out.println("两个对象是不同实例"); &#125; &#125;&#125; 运行截图如下图2 基于懒汉式单例实例代码 1234567891011121314151617181920212223242526public class Singleton &#123; private Singleton() &#123; &#125; //静态内部类 private static class SingletonHandler &#123; private final static Singleton instance = new Singleton(); &#125; public static Singleton getInstance() &#123; return SingletonHandler.instance; &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub Singleton s1, s2; s1 = Singleton.getInstance(); s2 = Singleton.getInstance(); System.out.println("两个对象实例是否相同？"); System.out.println(s1 == s2); &#125;&#125; 运行截图如下图3 饿汉式与懒汉式的比较&emsp;&emsp;&emsp;饿汉式单例类在类加载时就将自己实例化，它的优点在于无需考虑多个线程同时访问的问题，可以确保实例的唯一性；从调用速度和反应时间速度来讲，由于单例对象一开始就得以创建，因此要优于懒汉式单例。但是无论系统在运行时是否需要使用该单例对象，由于在类加载时该对象就需要创建，因此从资源利用效率角度来讲饿汉式单例不及懒汉式单例，而且在系统加载时由于需要创建饿汉式单例对象，加载时间可能会比较长。 &emsp;&emsp;&emsp;懒汉式单例类在第一次使用时创建，无须一直占用系统资源，实现了延迟加载，但是必须要处理多个线程同时访问的问题，特别是当单例类作为资源控制器，在实例化时必然涉及资源初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的几率比较大，需要通过同步化机制进行控制。 小结单例模式的主要优点在于提供了对唯一实例的受控访问并可以节约系统资源；其主要缺点在于因为缺少抽象层而难以扩展，且单例类职责过重。 单例模式适用情况包括：系统只需要一个实例对象；客户调用类的单个实例只允许使用一个公共访问点。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>单例模式</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈设计模式]]></title>
    <url>%2F2019%2F07%2F03%2F%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言在这篇文章中，我主要讲述以下内容： 引言 设计模式的诞生与发展 设计模式的定义与GoF23种设计模式 设计模式的优点 引言从两个实例说起：1. 实例一实例说明 某软件公司要开发一个跨平台图像浏览系统，要求该系统能够显示BMP、JPG、GIF、PNG等多种格式的文件，并且能够在Windows、Linux、Unix等多个操作系统上运行。系统首先将各种格式的文件解析为像素矩阵(Matrix)，然后将像素矩阵显示在屏幕上，在不同的操作系统中可以调用不同的绘制函数来绘制像素矩阵。 设计方案 问题 采用了多层继承结构，导致系统中类的个数急剧增加，具体层的类的个数 =所支持的图像文件格式数×所支持的操作系统数； 系统扩展麻烦，无论是增加新的图像文件格式还是增加新的操作系统，都需要增加大量的具体类，这将导致系统变得非常庞大，增加运行和维护开销。 2. 实例二实例说明 •某软件公司为某电影院开发了一套影院售票系统，在该系统中需要为不同类型的用户提供不同的电影票打折方式，具体打折方案如下： (1)学生凭学生证可享受票价8折优惠； (2)年龄在10周岁及以下的儿童可享受每张票减免10元的优惠（原始票价需大于等于20元）； (3)影院VIP用户除享受票价半价优惠外还可进行积分，积分累计到一定额度可换取电影院赠送的奖品。 注意：该系统在将来可能还要根据需要引入新的打折方式。 设计方案 1234567891011121314151617181920212223public class MovieTicket&#123; private double price; //compute the price public double calculate(String type) &#123; //student ticket if(type.equalsIgnoreCase("student")) &#123; return this.price * 0.8; &#125; //children ticket else if(type.equalsIgnoreCase("children") &amp;&amp; this.price &gt;= 20 ) &#123; return this.price - 10; &#125; //VIP ticket else if(type.equalsIgnoreCase("vip")) &#123; //add points, code is omitted return this.price * 0.5; &#125; else &#123; return this.price; &#125; &#125;&#125; 问题 (1) MovieTicket类的calculate()方法非常庞大，它包含各种打折算法的实现代码，在代码中出现了较长的条件转移语句，不利于测试和维护； (2) 在增加新的打折算法或者对原有打折算法进行修改时必须修改MovieTicket类的源代码，系统的灵活性和可扩展性较差； (3)算法的复用性差，如果另一个系统需要重用某些打折算法，只能通过对源代码进行复制粘贴来重用，无法单独重用其中的某个或某些算法。 设计模式的诞生与发展设计模式的诞生 设计模式起源于建筑业而非软件业 设计模式之父——美国加利佛尼亚大学环境结构中心研究所所长ChristopherAlexander博士 《APattern Language: Towns, Buildings, Construction》——253个建筑和城市规划模式 设计模式的发展 20世纪80年代末，软件工程界开始关注ChristopherAlexander等在这一住宅、公共建筑与城市规划领域的重大突破； “四人组(Gang of Four，GoF，分别是Erich Gamma, Richard Helm, Ralph Johnson和John Vlissides)”于1994年归纳发表了23种在软件开发中使用频率较高的设计模式，旨在用模式来统一沟通面向对象方法在分析、设计和实现间的鸿沟。 设计模式的定义与GoF23种设计模式设计模式的定义Alexander给出了关于模式的经典定义： &emsp;&emsp;&emsp;每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，通过这种方式，人们可以无数次地重用那些已有的解决方案，无须再重复相同的工作。 通俗理解：模式是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案。 GoF23种设计模式 备注：创建型模式主要是用于创建对象，结构性模式主要用于处理类或对象的组合，行为型模式主要用于描述类或对象怎样交互和怎样分配职责 设计模式的优点 融合了众多专家的经验，并以一种标准的形式供广大开发人员所用； 提供了一套通用的设计词汇和一种通用的语言，以方便开发人员之间进行沟通和交流，使得设计方案更加通俗易懂； 让人们可以更加简单方便地复用成功的设计和体系结构； 使得设计方案更加灵活，且易于修改； 将提高软件系统的开发效率和软件质量，且在一定程度上节约设计成本； 有助于初学者更深入地理解面向对象思想，方便阅读和学习现有类库与其他系统中的源代码，还可以提高软件的设计水平和代码质量。 小结&emsp;&emsp;&emsp;本文只是对设计模式进行了一个概述，具体常用的23种设计模式需要读者业余时间慢慢学习，同时需要知道的是在将来的软件设计与开发中使用设计模式，是一个成功的软件工程师必备的技能，这也正是我们学习设计模式的目的。 参考资料：Java设计模式——刘伟编著]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java开发环境搭建]]></title>
    <url>%2F2019%2F07%2F02%2FJava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[JDK的安装与配置1.获取JDK开发工具包（1）打开任意一款浏览器，到Java官网，打开Java官网主页，单击右上方的“ Java下载 ”项，进入最新的J2SE JDK下载页面； （2）单击“ jdk-11.0.3_windows-x64_bin.exe ”文件名，即可下载 jdk-11.0.3_windows-x64_bin.exe可执行文件。 2.安装JDK&emsp;&emsp;&emsp;找到下载的JDK文件jdk-11.0.3_windows-x64_bin.exe即可安装（由于我之前已经安装了，在这里我就不再描述），需要注意的是在安装过程中安装路径可以默认也可以自定义路径以及安装组件的全部安装还是选择部分安装（建议组件全部安装，避免后面出现不必要的麻烦），JDK类库安装完成后，会提示安装JRE环境，点击【更改】按钮可以更改JRE的安装路径，点击【下一步】进入JRE的安装。 3.配置JDK&emsp;&emsp;&emsp;安装JDK后，需要设置JAVA_Home、CLASSPATH以及PATH值（注意是在环境变量操作，而不是用户变量）。JDK具体配置步骤如下： （1）在Windows桌面上右击【我的电脑】图标，在弹出菜单中选择【属性】命令，打开【系统属性】对话框。 （2）在【系统属性】对话框中选择【高级】选项卡，如图①所示，点击【环境变量按钮】，打开【环境变量】对话框，如图②所示。 （3）在【环境变量】对话框的【系统变量】选项区域中，单击【新建】按钮，在【变量名】文本框中输入“ JAVA_HOME ”，在【变量值】文本框中输入“ C:\Program Files\Java\jdk1.8.0_121 ”（这个值是你安装JDK的路径），单击确定完成，如图③所示。 (4)在【环境变量】对话框的【系统变量】选项区域中，单击【新建】按钮，在【变量名】文本框中输入“ CLASSPATH ”，在【变量值】文本框中输入“ .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar ”，单击确定完成，如图④所示。 （5）在【环境变量】对话框的【系统变量】选项区域中选中变量“ Path ”，单击【编辑】按钮，在弹出的【编辑系统环境变量】对话框中加入“ %JAVA_HOME%\bin;”(即JDK bin目录所在的路径，注意若该路径为Path的最后一项则不需要加“ ; ”)，我这里加在最前面，因为放在前面可以改变它的优先级，如图⑤所示。 （6）检测JDK是否配置成功，可以打开命令提示符窗口，输入“ javac ”命令，如果配置成功，会出现当前javac命令相关的参数说明，如图⑥所示。 知识延伸（1）设置JAVA_HOME变量的作用是在其他变量中若要用到JDK的安装路径时，可用JAVA_HOME变量的值来替代换，使用时用%JAVA_HOME%表示。这样设置的优点是若改变了JDK的安装路径，只需要修改JAVA_HOME变量的值，而CLASSPATH及Path中的值不用修改。 （2）设置CLASSPATH主要用于说明JDK中所要用的类的位置，变量中的“ .; ”是不能省略的，“ . ”主要用于便是当前目录，而“ ; ”是各个部分的分隔符。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
</search>
