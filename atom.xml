<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YoHope</title>
  
  <subtitle>新的开始</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://YoHope99.github.io/"/>
  <updated>2019-09-28T07:03:51.212Z</updated>
  <id>http://YoHope99.github.io/</id>
  
  <author>
    <name>YoHope</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用MySQL的异常错误</title>
    <link href="http://YoHope99.github.io/2019/09/28/%E4%BD%BF%E7%94%A8MySQL%E7%9A%84%E5%BC%82%E5%B8%B8%E9%94%99%E8%AF%AF/"/>
    <id>http://YoHope99.github.io/2019/09/28/使用MySQL的异常错误/</id>
    <published>2019-09-28T06:48:55.000Z</published>
    <updated>2019-09-28T07:03:51.212Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>今天连接MySQL数据库时控制台突然报错，显示为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.sql.SQLException: The server time zone value <span class="string">'�й���׼ʱ��'</span> is unrecognized or represents more than one time zone. <span class="function">You must configure either the server or JDBC <span class="title">driver</span> <span class="params">(via the serverTimezone configuration property)</span> to use a more specifc time zone value <span class="keyword">if</span> you want to utilize time zone support.</span></span><br></pre></td></tr></table></figure><p><strong>这里可以看出是时间区域的问题。</strong></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在配置数据库的连接信息中，在MySQL的URL后面加上“<strong>?serverTimezone=UTC</strong>“，即是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/spring_cache?serverTimezone=UTC</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;今天连接MySQL数据库时控制台突然报错，显示为：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
      <category term="MySQL" scheme="http://YoHope99.github.io/categories/MySQL/"/>
    
    
      <category term="Spring" scheme="http://YoHope99.github.io/tags/Spring/"/>
    
      <category term="MySQL" scheme="http://YoHope99.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java创建多线程的三种方式</title>
    <link href="http://YoHope99.github.io/2019/08/27/Java%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://YoHope99.github.io/2019/08/27/Java创建多线程的三种方式/</id>
    <published>2019-08-27T07:38:32.000Z</published>
    <updated>2019-09-01T11:50:14.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇文章主要讲述线程的概念、组成、Java创建多线程的三种方式以及线程的类型。</p><h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h2><h3 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h3><p><strong>进程：</strong>正在运行的程序，例如：你打开 的qq音乐.exe程序，其由PCB（进程控制块）、栈、程序、数据组成。</p><p><strong>线程：</strong>是一个进程中的程序代码的一个执行序列，被认为是带有自己的程序代码和数据的虚拟处理机的封装，其由处理机、代码、数据三部分组成，你可以这样理解线程是在进程内部同时做的事情，比如你在qq音乐应用里可以一边听音乐、同时下载音乐。这就是由多线程来实现的。<strong>（一个进程至少包含一个或者多个线程）</strong></p><a id="more"></a><p><strong>注意：</strong></p><ol><li><em>每个Java程序都有一个隐含的主线程，即main()方法，要实现多线程必须在主线程中创建新的线程，Java语言使用Thread类及其子类的对象来表示线程；</em></li><li><em>一个虚拟处理机封装在java.lang.Thread类中，它控制着整个线程的运行；CPU执行的代码传递给Thread类，由Thread类控制顺序执行；处理的数据传递给Thread类，是在代码执行的过程中所要处理的数据。代码和数据可以由多个线程共享，也可以不被共享，代码和数据是相互独立的，当两个线程共享同一个类的实例时，他们就共享相同的代码；当两个线程共享一个公共对象的存取时，他们就共享相同的数据。</em></li></ol><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>一个线程从它被创建到停止执行要经历一个完整的生命周期，在这个生命周期中有4种不同的状态。</p><p>①New（新）   ②Runnable（可运行）    ③Blocked（被阻塞）    ④Dead（死亡）</p><h2 id="创建线程的三种方式"><a href="#创建线程的三种方式" class="headerlink" title="创建线程的三种方式"></a>创建线程的三种方式</h2><h3 id="通过继承Thread类"><a href="#通过继承Thread类" class="headerlink" title="通过继承Thread类"></a>通过继承Thread类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">String threadName;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadTest1</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Making thread:"</span>+s);</span><br><span class="line">threadName = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ )&#123;</span><br><span class="line">System.out.println(<span class="string">"Running thread number ="</span> + threadName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>); <span class="comment">//线程睡眠1秒</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主线程，操作系统调度每个线程执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">ThreadTest1 thread1 = <span class="keyword">new</span> ThreadTest1(<span class="string">"Tom"</span>); <span class="comment">//线程1Tom</span></span><br><span class="line">ThreadTest1 thread2 = <span class="keyword">new</span> ThreadTest1(<span class="string">"Jack"</span>); <span class="comment">//线程2Jack</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**线程启动，不是直接调用 run() 方法，而是调运线程类 Thread 的 start() 方法，</span></span><br><span class="line"><span class="comment">*在 Thread 方法内部会调用本地系统方法，最终会自动调用自己线程类的 run()方法。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">thread1.start(); </span><br><span class="line">thread2.start();</span><br><span class="line">System.out.println(<span class="string">"End of main"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行截图</strong></p><p><img src="https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BB%A7%E6%89%BFThread.png" alt></p><h3 id="通过实现Runnable接口"><a href="#通过实现Runnable接口" class="headerlink" title="通过实现Runnable接口"></a>通过实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">String threadName;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadTest</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Making thread:"</span>+s);</span><br><span class="line">threadName = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ )&#123;</span><br><span class="line">System.out.println(<span class="string">"Running thread number ="</span> + threadName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>); <span class="comment">//让线程睡眠1秒</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主线程，操作系统调度每个线程执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程Tom和线程Jack</span></span><br><span class="line">Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadTest(<span class="string">"Tom"</span>)); </span><br><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadTest(<span class="string">"Jack"</span>)); </span><br><span class="line"></span><br><span class="line"><span class="comment">/**线程启动，不是直接调用 run() 方法，而是调运线程类 Thread 的 start() 方法，</span></span><br><span class="line"><span class="comment">*在 Thread 方法内部会调用本地系统方法，最终会自动调用自己线程类的 run()方法。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">thread1.start(); </span><br><span class="line">thread2.start();</span><br><span class="line">System.out.println(<span class="string">"End of main"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行截图</strong></p><p><img src="https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%AE%9E%E7%8E%B0Runnable.png" alt></p><h3 id="通过实现Callable接口"><a href="#通过实现Callable接口" class="headerlink" title="通过实现Callable接口"></a>通过实现Callable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">String threadName;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadTest</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Making thread:"</span>+s);</span><br><span class="line">threadName = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ )&#123;</span><br><span class="line">System.out.println(threadName+i);</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建两个线程,并且启动</span></span><br><span class="line">ThreadTest threadTest1 = <span class="keyword">new</span> ThreadTest(<span class="string">"Tom"</span>);</span><br><span class="line">ThreadTest threadTest2 = <span class="keyword">new</span> ThreadTest(<span class="string">"Jack"</span>);</span><br><span class="line"></span><br><span class="line">FutureTask&lt;Integer&gt; result1 = <span class="keyword">new</span> FutureTask&lt;&gt;(threadTest1);</span><br><span class="line"><span class="keyword">new</span> Thread(result1).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     FutureTask&lt;Integer&gt; result2 = <span class="keyword">new</span> FutureTask&lt;&gt;(threadTest2);</span><br><span class="line"><span class="keyword">new</span> Thread(result2).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行截图</strong></p><p><img src="https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%AE%9E%E7%8E%B0Callable.png" alt></p><h2 id="线程类型分类"><a href="#线程类型分类" class="headerlink" title="线程类型分类"></a>线程类型分类</h2><p>java中线程一共有两种类型，守护线程和用户线程，用户线程又叫非守护线程。</p><ul><li>守护线程</li></ul><p>可以通过<code>thread.setDaemon(true)</code>方法设置线程是否为守护线程，<code>thread.setDaemon(true)</code>必须在<code>thread.start()</code>之前设置，否则会抛出<code>IllegalThreadStateException</code>异常。在守护线程中开启的新线程也是守护线程。守护线程顾名思义是用来守护的，是给所有的非守护线程提供服务的，所以在<code>JVM</code>执行完所有的非守护线程后，<code>JVM</code>就会停止，守护线程也不在运行，最典型的守护线程就是java的垃圾回收机制（<code>GC</code>）。</p><ul><li>非守护线程</li></ul><p>java线程默认设置为非守护线程<code>thread.setDaemon(false)</code>。当主线程运行完之后，只要主线程里有非守护线程<code>JVM</code>就互惠退出，直到所有的非守护线程执行完之后<code>JVM</code>才会退出。、</p><blockquote><p>总结：如果把一个线程设置成守护线程，则JVM的退出就不会关心当前线程的执行状态。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这篇文章主要讲述线程的概念、组成、Java创建多线程的三种方式以及线程的类型。&lt;/p&gt;
&lt;h2 id=&quot;线程概念&quot;&gt;&lt;a href=&quot;#线程概念&quot; class=&quot;headerlink&quot; title=&quot;线程概念&quot;&gt;&lt;/a&gt;线程概念&lt;/h2&gt;&lt;h3 id=&quot;线程和进程的区别&quot;&gt;&lt;a href=&quot;#线程和进程的区别&quot; class=&quot;headerlink&quot; title=&quot;线程和进程的区别&quot;&gt;&lt;/a&gt;线程和进程的区别&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;进程：&lt;/strong&gt;正在运行的程序，例如：你打开 的qq音乐.exe程序，其由PCB（进程控制块）、栈、程序、数据组成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程：&lt;/strong&gt;是一个进程中的程序代码的一个执行序列，被认为是带有自己的程序代码和数据的虚拟处理机的封装，其由处理机、代码、数据三部分组成，你可以这样理解线程是在进程内部同时做的事情，比如你在qq音乐应用里可以一边听音乐、同时下载音乐。这就是由多线程来实现的。&lt;strong&gt;（一个进程至少包含一个或者多个线程）&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="多线程" scheme="http://YoHope99.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://YoHope99.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://YoHope99.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>YAML语法</title>
    <link href="http://YoHope99.github.io/2019/08/08/YAML%E8%AF%AD%E6%B3%95/"/>
    <id>http://YoHope99.github.io/2019/08/08/YAML语法/</id>
    <published>2019-08-08T10:42:17.000Z</published>
    <updated>2019-08-08T11:47:39.783Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>　　　在用Spring Boot的过程中，我们经常需要编写application.properties或者application.yml配置文件来改变Spring Boot的默认配置，因此本文主要讲解yaml的语法用法。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>key:(空格)value：表示一对键值对（空格必须有）；</p><p>以<strong>空格</strong>的缩进来控制层级关系，只要是左对齐的一列数据，都是同一个层级的关系。</p><a id="more"></a><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">8082</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/hello</span></span><br></pre></td></tr></table></figure><p><strong><em>注意：属性和值都是大小写敏感的。</em></strong></p><h2 id="值的写法"><a href="#值的写法" class="headerlink" title="值的写法"></a>值的写法</h2><h3 id="字面量：普通的值（数字、字符串、布尔类型）"><a href="#字面量：普通的值（数字、字符串、布尔类型）" class="headerlink" title="字面量：普通的值（数字、字符串、布尔类型）"></a>字面量：普通的值（数字、字符串、布尔类型）</h3><p>key: value：字面直接来写；</p><ul><li><p>字符串默认不用加上单引号或者双引号；</p></li><li><p>“ ”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身所想表达的意思</p><p>例如：name:   “zhangsan \n lisi”：输出是：zhangsan 换行  lisi</p></li><li><p>‘ ‘：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据</p><p>例如：name:   ‘zhangsan \n lisi’：输出是：zhangsan \n  lisi</p></li></ul><h3 id="对象、Map（属性和值）（键值对）："><a href="#对象、Map（属性和值）（键值对）：" class="headerlink" title="对象、Map（属性和值）（键值对）："></a>对象、Map（属性和值）（键值对）：</h3><p>key: value：在下一行来写对象的属性和值的关系；<strong>注意缩进</strong></p><p>　　　　　　对象还是Key: value的方式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">zhangsan</span></span><br><span class="line"><span class="attr">    age:</span> <span class="number">24</span></span><br></pre></td></tr></table></figure><p>行内写法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span> <span class="string">&#123;name:</span> <span class="string">zhangsan,age:</span> <span class="number">24</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="数组（List、Set）"><a href="#数组（List、Set）" class="headerlink" title="数组（List、Set）"></a>数组（List、Set）</h3><p>用- 值表示数组中的一个元素</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pets:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">dog</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cat</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">pig</span></span><br></pre></td></tr></table></figure><p>行内写法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pets:</span> <span class="string">[dog,cat,pig]</span></span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>yaml的语法是一个把空格玩到极致的，在编写的时候我们需要注意空格就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;　　　在用Spring Boot的过程中，我们经常需要编写application.properties或者application.yml配置文件来改变Spring Boot的默认配置，因此本文主要讲解yaml的语法用法。&lt;/p&gt;
&lt;h2 id=&quot;基本语法&quot;&gt;&lt;a href=&quot;#基本语法&quot; class=&quot;headerlink&quot; title=&quot;基本语法&quot;&gt;&lt;/a&gt;基本语法&lt;/h2&gt;&lt;p&gt;key:(空格)value：表示一对键值对（空格必须有）；&lt;/p&gt;
&lt;p&gt;以&lt;strong&gt;空格&lt;/strong&gt;的缩进来控制层级关系，只要是左对齐的一列数据，都是同一个层级的关系。&lt;/p&gt;
    
    </summary>
    
      <category term="YAML" scheme="http://YoHope99.github.io/categories/YAML/"/>
    
    
      <category term="yaml语法" scheme="http://YoHope99.github.io/tags/yaml%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Docker的安装以及解决启动失败问题</title>
    <link href="http://YoHope99.github.io/2019/07/28/Docker%E7%9A%84%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/"/>
    <id>http://YoHope99.github.io/2019/07/28/Docker的安装以及解决启动失败问题/</id>
    <published>2019-07-28T10:51:33.000Z</published>
    <updated>2019-07-28T12:00:02.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>　　本文章主要讲解在Linux虚拟机上安装Docker以及安装后启动失败的问题。</p><h2 id="在Linux虚拟机上安装Docker以及解决启动问题"><a href="#在Linux虚拟机上安装Docker以及解决启动问题" class="headerlink" title="在Linux虚拟机上安装Docker以及解决启动问题"></a>在Linux虚拟机上安装Docker以及解决启动问题</h2><p><strong>步骤：</strong></p><ol><li>检查Linux系统内核版本，必须是3.10及以上<code>uname -r</code><a id="more"></a></li></ol><p><img src="https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/version.png" alt></p><ol start="2"><li>安装docker，<code>yum install docker</code>，输入<strong>y</strong>确定安装，知道出现<strong><em>Complete!</em></strong>表示安装已经完成</li></ol><p><img src="https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/%E5%AE%89%E8%A3%85docker.png" alt></p><ol start="3"><li>启动docker，<code>systemctl start docker</code>，发现启动不了</li></ol><p><img src="https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/docker%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5.png" alt></p><ol start="4"><li>输入<code>systemctl status docker.service</code>命令会发现提示以下错误提示</li></ol><p><img src="https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/docker%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA.png" alt></p><p><strong>错误信息表示：</strong></p><p><strong><em>此linux的内核中的SELinux不支持 overlay2 graph driver ，解决方法有两个，要么启动一个新内核，要么就在docker里禁用selinux，–selinux-enabled=false；</em></strong></p><ol start="5"><li>解决方案：</li></ol><p>用vi编辑器打开docker配置文件，修改配置信息，在<strong>–selinux-enabled</strong>后面添加<strong>=false</strong>，如下：</p><p><img src="https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/%E4%BF%AE%E6%94%B9docker%E9%85%8D%E7%BD%AE.png" alt></p><ol start="6"><li>输入<code>systemctl start docker</code>命令，重新启动发现可以正常启动了。</li></ol><p><img src="https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/docker%E6%AD%A3%E5%B8%B8%E5%90%AF%E5%8A%A8.png" alt></p><h2 id="设置虚拟机开机启动docker"><a href="#设置虚拟机开机启动docker" class="headerlink" title="设置虚拟机开机启动docker"></a>设置虚拟机开机启动docker</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# systemctl enable docker</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;　　本文章主要讲解在Linux虚拟机上安装Docker以及安装后启动失败的问题。&lt;/p&gt;
&lt;h2 id=&quot;在Linux虚拟机上安装Docker以及解决启动问题&quot;&gt;&lt;a href=&quot;#在Linux虚拟机上安装Docker以及解决启动问题&quot; class=&quot;headerlink&quot; title=&quot;在Linux虚拟机上安装Docker以及解决启动问题&quot;&gt;&lt;/a&gt;在Linux虚拟机上安装Docker以及解决启动问题&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检查Linux系统内核版本，必须是3.10及以上&lt;code&gt;uname -r&lt;/code&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://YoHope99.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://YoHope99.github.io/tags/Docker/"/>
    
      <category term="Linux" scheme="http://YoHope99.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>有趣的二进制问题</title>
    <link href="http://YoHope99.github.io/2019/07/25/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%97%AE%E9%A2%98/"/>
    <id>http://YoHope99.github.io/2019/07/25/有趣的二进制问题/</id>
    <published>2019-07-25T08:30:39.000Z</published>
    <updated>2019-07-25T09:09:51.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于最近在忙其他事情而导致一周多没有写博客了，趁今天下午有空，也想起了一个之前看到的有趣的二进制问题，所以这次博文就探讨一下这个有趣的问题。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有1000瓶水，其中999瓶没有毒药，只有1瓶有毒药，只要一喝到毒药就会在一天后死亡，给你10个老鼠和1天的时间，问你怎样在规定的条件内快速找到哪一瓶水含有毒药？</p><a id="more"></a><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li><p>对1000瓶水贴上二进制编号（10位）：</p><p>1号 ———–0000000001</p><p>2号 ———–0000000010</p><p>3号 ———–0000000011</p><p>……………………………………</p><p>999号 ——–1111100111</p></li></ul><p>​       1000号 ——–1111101000</p><ul><li><p>对10只老鼠进行编号：</p><p>分别是A，B，C，D，E，F，G，H，I，J</p></li><li><p>让A~J老鼠分别喝同一列编码是1的水，即：</p><p><strong>A老鼠喝编码格式为xxxxxxxxx1的水</strong></p><p><strong>B老鼠喝编码格式为xxxxxxxx1x的水</strong></p><p><strong>C老鼠喝编码格式为xxxxxxx1xx的水</strong></p><p><strong>D老鼠喝编码格式为xxxxxx1xxx的水</strong></p><p><strong>E老鼠喝编码格式为xxxxx1xxxx的水</strong></p><p><strong>F老鼠喝编码格式为xxxx1xxxxx的水</strong></p><p><strong>G老鼠喝编码格式为xxx1xxxxxx的水</strong></p><p><strong>H老鼠喝编码格式为xx1xxxxxxx的水</strong></p><p><strong>I老鼠喝编码格式为x1xxxxxxxx的水</strong></p><p><strong>J老鼠和编码格式为1xxxxxxxxx的水</strong></p></li><li><p>假如<strong><em>A，D，I</em></strong>老鼠死了，那个该水含有毒药的编号就是<strong>0100001001</strong>，化为10进制为<strong>265号</strong>。</p></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>以上就是一个二进制比较有趣的问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;由于最近在忙其他事情而导致一周多没有写博客了，趁今天下午有空，也想起了一个之前看到的有趣的二进制问题，所以这次博文就探讨一下这个有趣的问题。&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;有1000瓶水，其中999瓶没有毒药，只有1瓶有毒药，只要一喝到毒药就会在一天后死亡，给你10个老鼠和1天的时间，问你怎样在规定的条件内快速找到哪一瓶水含有毒药？&lt;/p&gt;
    
    </summary>
    
      <category term="二进制" scheme="http://YoHope99.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
    
      <category term="二进制" scheme="http://YoHope99.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Spring中Bean的装配方式</title>
    <link href="http://YoHope99.github.io/2019/07/17/Spring%E4%B8%ADBean%E7%9A%84%E8%A3%85%E9%85%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://YoHope99.github.io/2019/07/17/Spring中Bean的装配方式/</id>
    <published>2019-07-17T08:18:03.000Z</published>
    <updated>2019-08-09T11:35:17.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bean的装配可以理解为依赖关系注入，Bean的装配方式即Bean依赖注入的方式。Spring容器支持多种形式的Bean的装配方式，如<strong>基于XML的装配、基于注解（Annotation）的装配和自动装配（其中最常用的是基于注解的装配）</strong>，本文章将主要讲解着三种装配方式的使用。</p><h2 id="基于XML的装配"><a href="#基于XML的装配" class="headerlink" title="基于XML的装配"></a>基于XML的装配</h2><a id="more"></a><h3 id="方式一：设置注入"><a href="#方式一：设置注入" class="headerlink" title="方式一：设置注入"></a>方式一：设置注入</h3><p>   条件：①Bean类必须有一个无参构造方法；②Bean类必须为属性提供setter方法。</p><p>   <strong><em>在配置文件中，使用<property>元素来为每个属性注入值</property></em></strong></p><h3 id="方式二：构造注入"><a href="#方式二：构造注入" class="headerlink" title="方式二：构造注入"></a>方式二：构造注入</h3><p>   条件：Bean类必须提供有参构造方法</p><p>   <strong><em>在配置文件中，使用<constructor-arg>元素来为参数注入值</constructor-arg></em></strong></p><h3 id="具体实现步骤如下"><a href="#具体实现步骤如下" class="headerlink" title="具体实现步骤如下"></a>具体实现步骤如下</h3><ol><li><p>创建Java类User，提供有参、无参构造方法以及属性setter方法；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package com.ssm.assemble;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    private String username;</span><br><span class="line">    private Integer password;</span><br><span class="line">    private List&lt;String&gt; list;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 1.使用构造注入</span><br><span class="line">     * 1.1提供带所有参数的有参构造方法。</span><br><span class="line">     */</span><br><span class="line">    public User(String username, Integer password, List&lt;String&gt; list) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.username = username;</span><br><span class="line">        this.password = password;</span><br><span class="line">        this.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 2.使用设值注入</span><br><span class="line">     * 2.1提供默认空参构造方法 ;</span><br><span class="line">     * 2.2为所有属性提供setter方法。</span><br><span class="line">     */</span><br><span class="line">    public User() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setPassword(Integer password) &#123;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setList(List&lt;String&gt; list) &#123;</span><br><span class="line">        this.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User [username=&quot; + username + &quot;, password=&quot; + password +</span><br><span class="line">                &quot;, list=&quot; + list + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Spring配置文件beans1.xml，使用以上两种方式装配Bean;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line"> http://www.springframework.org/schema/beans/spring-beans-4.3.xsd&quot;&gt;</span><br><span class="line">  </span><br><span class="line">    &lt;!--1.使用构造注入方式装配User实例 --&gt;</span><br><span class="line">    &lt;bean id=&quot;user1&quot; class=&quot;com.ssm.assemble.User&quot;&gt;</span><br><span class="line">        &lt;constructor-arg index=&quot;0&quot; value=&quot;小红&quot; /&gt;</span><br><span class="line">        &lt;constructor-arg index=&quot;1&quot; value=&quot;987654&quot; /&gt;</span><br><span class="line">        &lt;constructor-arg index=&quot;2&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;&quot;constructorvalue1&quot;&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;&quot;constructorvalue2&quot;&lt;/value&gt;</span><br><span class="line">            &lt;/list&gt;</span><br><span class="line">        &lt;/constructor-arg&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">  </span><br><span class="line">    &lt;!--2.使用设值注入方式装配User实例 --&gt;</span><br><span class="line">    &lt;bean id=&quot;user2&quot; class=&quot;com.ssm.assemble.User&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;小明&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;!-- 注入list集合 --&gt;</span><br><span class="line">        &lt;property name=&quot;list&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;&quot;setlistvalue1&quot;&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;&quot;setlistvalue2&quot;&lt;/value&gt;</span><br><span class="line">            &lt;/list&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建测试类XmlBeanAssembleTest，测试程序；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.ssm.assemble;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">public class XmlBeanAssembleTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 定义配置文件路径</span><br><span class="line">        String xmlPath = &quot;beans1.xml&quot;;</span><br><span class="line">        // 加载配置文件</span><br><span class="line">        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath);</span><br><span class="line">        // 构造方式输出结果</span><br><span class="line">        System.out.println(applicationContext.getBean(&quot;user1&quot;));</span><br><span class="line">        // 设值方式输出结果</span><br><span class="line">        System.out.println(applicationContext.getBean(&quot;user2&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>运行效果。</p><p><img src="https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/XML%E6%96%B9%E5%BC%8F%E7%BB%84%E8%A3%85Bean.png" alt></p></li></ol><h2 id="基于注解的装配"><a href="#基于注解的装配" class="headerlink" title="基于注解的装配"></a>基于注解的装配</h2><p>　　由于基于XML的装配可能会导致XML配置文件过于臃肿，给后续的维护和升级带来一定的困难。因此，Spring提供了对Annotation（注解）技术的全面支持。</p><p><img src="https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/%E4%B8%BB%E8%A6%81%E6%B3%A8%E8%A7%A3.png" alt> </p><h3 id="具体实现步骤如下-1"><a href="#具体实现步骤如下-1" class="headerlink" title="具体实现步骤如下"></a>具体实现步骤如下</h3><ol><li>创建数据访问（Dao）层接口UserDao；</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package com.ssm.annotation;</span><br><span class="line"></span><br><span class="line">public interface UserDao &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建数据访问（UserDao）层接口的实现类UserDaoImpl，并且在实现类前添加对应的注解@Repository(“userDao”)；</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.ssm.annotation;</span><br><span class="line">import org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line">@Repository(&quot;userDao&quot;)</span><br><span class="line">//@Repository(&quot;userDao&quot;)相当于配置文件中的:&lt;bean id=&quot;userDao&quot; class=&quot;com.ssm.annotation.UserDaoImpl&quot; /&gt;</span><br><span class="line"></span><br><span class="line">public class UserDaoImpl implements UserDao&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;userdao...save...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>创建业务（Service）层接口UserService；</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package com.ssm.annotation;</span><br><span class="line"></span><br><span class="line">public interface UserService &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>创建业务（Service）层接口的实现类UserServiceImpl并添加属性对象UserDao的setter方法，并在实现类前添加对应的注解@Service(“userService”)和在类里面方法前添加对应的注解 @Resource(name=”userDao”)；</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.ssm.annotation;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service(&quot;userService&quot;)</span><br><span class="line">//相当于配置文件中的:&lt;bean id=&quot;userService&quot; class=&quot;com.ssm.annotation.UserServiceImpl&quot; /&gt;</span><br><span class="line"></span><br><span class="line">public class UserServiceImpl implements UserService&#123;</span><br><span class="line">    @Resource(name=&quot;userDao&quot;)</span><br><span class="line">    //当于配置文件中的:&lt;property name=&quot;userDao&quot;  ref=&quot;userDao&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    private UserDao userDao; </span><br><span class="line">    public void save() &#123;</span><br><span class="line">        //调用userDao中的save方法</span><br><span class="line">        this.userDao.save();</span><br><span class="line">        System.out.println(&quot;userservice....save...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUserDao(UserDao userDao) &#123;</span><br><span class="line">        this.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>创建控制（Controller）层Java类UserController，并在实现类前添加对应的注解@Controller(“userController”)和在类里面方法前添加对应的注解 @Resource(name=”userService”)；</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.ssm.annotation;</span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line"></span><br><span class="line">@Controller(&quot;userController&quot;)</span><br><span class="line">//相当于配置文件中的:&lt;bean id=&quot;userController&quot; class=&quot;com.ssm.annotation.UserController&quot; /&gt;</span><br><span class="line"></span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @Resource(name=&quot;userService&quot;)</span><br><span class="line">    //当于配置文件中的:&lt;property name=&quot;userService&quot;  ref=&quot;userService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    private UserService userService;</span><br><span class="line">    public void save()&#123;</span><br><span class="line">        this.userService.save();</span><br><span class="line">        System.out.println(&quot;userController...save...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUserService(UserService userService) &#123;</span><br><span class="line">        this.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>创建Spring配置文件beans2.xml，开启注解和定义Bean;</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">      http://www.springframework.org/schema/beans/spring-beans-4.3.xsd</span><br><span class="line">      http://www.springframework.org/schema/context</span><br><span class="line">  http://www.springframework.org/schema/context/spring-context-4.3.xsd&quot;&gt;</span><br><span class="line">  </span><br><span class="line">    &lt;!-- 使用 context 命名空间 ,在配置文件中开启相应的注解处理器 --&gt;</span><br><span class="line">    &lt;context:annotation-config /&gt;</span><br><span class="line">    &lt;!--使用 context 命名空间 ,通知Spring扫描指定包下所有Bean类，进行注解解析--&gt;</span><br><span class="line">    &lt;context:component-scan base-package=&quot;com.ssm.annotation&quot; /&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><ol start="7"><li>创建测试类AnnotationAssembleTest，测试程序；</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.ssm.annotation;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line">public class AnnotationAssembleTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 定义配置文件路径</span><br><span class="line">        String xmlPath = &quot;beans2.xml&quot;;</span><br><span class="line">        // 加载配置文件</span><br><span class="line">        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath);</span><br><span class="line">        // 获取UserController实例</span><br><span class="line">        UserController userController = (UserController) applicationContext.getBean(&quot;userController&quot;);</span><br><span class="line">        // 调用UserController中的save()方法</span><br><span class="line">        userController.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>运行效果。</li></ol></li></ol><p><img src="https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/%E6%B3%A8%E8%A7%A3%E8%A3%85%E9%85%8D.png" alt></p><h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p>   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓自动装配，就是将一个Bean自动的注入到到其他Bean的Property中。 Spring的<bean>元素中包含一个autowire属性，我们可以通过设置autowire的属性值来自动装配Bean。autowire属性有5个值，其值及说明下表所示：<br>   <img src="https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/autowire%E5%B1%9E%E6%80%A7.png" alt></bean></p><h3 id="具体实现步骤如下-2"><a href="#具体实现步骤如下-2" class="headerlink" title="具体实现步骤如下"></a>具体实现步骤如下</h3><p>   这里只需要在基于注解的装配配置文件（beans.xml）中把注解方式换成自动装配即可，具体代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>    </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">     http://www.springframework.org/schema/beans/spring-beans-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">     http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string"> http://www.springframework.org/schema/context/spring-context-4.3.xsd"</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 使用 context 命名空间 ,在配置文件中开启相应的注解处理器 --&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--&lt;context:annotation-config /&gt;--&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--&amp;lt;!&amp;ndash;分别定义3个Bean实例  &amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--&lt;bean id="userDao" class="com.ssm.annotation.UserDaoImpl" /&gt;--&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--&lt;bean id="userService" class="com.ssm.annotation.UserServiceImpl" /&gt;--&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--&lt;bean id="userController" class="com.ssm.annotation.UserController" /&gt;--&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--&amp;lt;!&amp;ndash;使用 context 命名空间 ,通知Spring扫描指定包下所有Bean类，进行注解解析&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--&lt;context:component-scan base-package="com.ssm.annotation" /&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 使用bean元素的autowire属性完成自动装配 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">class</span>=<span class="string">"com.ssm.annotation.UserDaoImpl"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">class</span>=<span class="string">"com.ssm.annotation.UserServiceImpl"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userController"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">class</span>=<span class="string">"com.ssm.annotation.UserController"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  <strong><em>运行效果和基于注解的装配一样</em></strong></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上就是Spring中Bean的三种装配方式，其中我们需要重点掌握第二种基于注解的装配，它是我们日常工作最常用的一种装配。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;   &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Bean的装配可以理解为依赖关系注入，Bean的装配方式即Bean依赖注入的方式。Spring容器支持多种形式的Bean的装配方式，如&lt;strong&gt;基于XML的装配、基于注解（Annotation）的装配和自动装配（其中最常用的是基于注解的装配）&lt;/strong&gt;，本文章将主要讲解着三种装配方式的使用。&lt;/p&gt;
&lt;h2 id=&quot;基于XML的装配&quot;&gt;&lt;a href=&quot;#基于XML的装配&quot; class=&quot;headerlink&quot; title=&quot;基于XML的装配&quot;&gt;&lt;/a&gt;基于XML的装配&lt;/h2&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://YoHope99.github.io/categories/Spring/"/>
    
    
      <category term="Java" scheme="http://YoHope99.github.io/tags/Java/"/>
    
      <category term="Spring" scheme="http://YoHope99.github.io/tags/Spring/"/>
    
      <category term="Bean的装配" scheme="http://YoHope99.github.io/tags/Bean%E7%9A%84%E8%A3%85%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>谈谈快速排序</title>
    <link href="http://YoHope99.github.io/2019/07/13/%E8%B0%88%E8%B0%88%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://YoHope99.github.io/2019/07/13/谈谈快速排序/</id>
    <published>2019-07-13T00:40:47.000Z</published>
    <updated>2019-07-25T06:24:19.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;&nbsp;&nbsp;本文章主要讲解快速排序的原理以及代码实现。</p><h2 id="快速排序基于的思想（分治法）"><a href="#快速排序基于的思想（分治法）" class="headerlink" title="快速排序基于的思想（分治法）"></a>快速排序基于的思想（分治法）</h2><h3 id="分治法的简述"><a href="#分治法的简述" class="headerlink" title="分治法的简述"></a>分治法的简述</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;分治法是指将一个难以直接解决的大问题，划分成一些规模较小的子问题，以便各个击破，分而治之。</p><p><img src="https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/%E5%88%86%E6%B2%BB%E6%B3%95%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt></p><a id="more"></a><h3 id="分治法的求解过程"><a href="#分治法的求解过程" class="headerlink" title="分治法的求解过程"></a>分治法的求解过程</h3><p><strong>分治法求解问题的主要步骤：划分，求解，合并。</strong></p><p>（1）问题划分。将规模为n的问题划分成k个子问题；</p><p>（2）求解子问题。各子问题的求解方法相同，通常采用递归方法实现；</p><p>（3）合并子问题的解。将各子问题的解逐层合并，得到问题的最终解。</p><h2 id="快速排序的分治策略"><a href="#快速排序的分治策略" class="headerlink" title="快速排序的分治策略"></a>快速排序的分治策略</h2><p>（1）划分：选定一个记录作为轴值，以轴值为基准将整个序列划分为两个子序列r1… ri-1和ri+1 … rn，前一个子    序列中记录的值均小于或等于轴值，后一个子序列中记录的值均大于或等于轴值；</p><p>（2）求解子问题：分别对划分后的每一个子序列递归处理；</p><p>（3）合并：由于对子序列r1 … ri-1和ri+1 … rn的排序是就地进行的，所以合并不需要执行任何操作。</p><p><img src="https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png" alt></p><h2 id="举例子说明"><a href="#举例子说明" class="headerlink" title="举例子说明"></a>举例子说明</h2><p><strong>对序列[23,13,35,6,19,50,28]进行快速排序的过程。（注意：这里以第一个记录作为轴值，黑体代表轴值）</strong></p><p>一次划分过程，如下图：</p><p><img src="https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/%E5%88%92%E5%88%86%E8%BF%87%E7%A8%8B.jpg" alt></p><p>以轴值为基准将待排序序列划分为两个子序列后，对每一个子序列分别递归进行处理，下图是一个快速排序的完整的例子。</p><p><img src="https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.jpg" alt></p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> r[ ], <span class="keyword">int</span> first, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i=first, j=end;         <span class="comment">//初始化</span></span><br><span class="line">      <span class="keyword">int</span> temp;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">while</span> (i&lt;j)</span><br><span class="line">       &#123;  </span><br><span class="line">           <span class="keyword">while</span> (i&lt;j &amp;&amp; r[i]&lt;= r[j]) </span><br><span class="line">               j--;        <span class="comment">//右侧扫描</span></span><br><span class="line">           <span class="keyword">if</span> (i&lt;j) &#123; </span><br><span class="line">               temp=r[i]; r[i]=r[j]; r[j]=temp;   <span class="comment">//将较小记录交换到前面</span></span><br><span class="line">               i++; </span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">while</span> (i&lt;j &amp;&amp; r[i]&lt;= r[j]) </span><br><span class="line">               i++;     <span class="comment">//左侧扫描 </span></span><br><span class="line">               <span class="keyword">if</span> (i&lt;j) &#123;</span><br><span class="line">                  temp=r[i]; r[i]=r[j]; r[j]=temp;   <span class="comment">//将较大记录交换到后面</span></span><br><span class="line">                  j--; </span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">      <span class="keyword">return</span> i;      <span class="comment">// i为轴值记录的最终位置</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> r[ ], <span class="keyword">int</span> first, <span class="keyword">int</span> end)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="keyword">int</span> mid; <span class="comment">//划分后的轴值位置</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">if</span> (first &lt; end) &#123;      </span><br><span class="line">     mid = Partition(r, first, end);     <span class="comment">//划分，mid是轴值在序列中的位置</span></span><br><span class="line">     QuickSort(r, first, mid<span class="number">-1</span>);        <span class="comment">//求解子问题1，对左侧子序列进行快速排序</span></span><br><span class="line">     QuickSort(r, mid+<span class="number">1</span>, end);          <span class="comment">//求解子问题2，对右侧子序列进行快速排序</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序时间复杂度和空间复杂度分析"><a href="#快速排序时间复杂度和空间复杂度分析" class="headerlink" title="快速排序时间复杂度和空间复杂度分析"></a>快速排序时间复杂度和空间复杂度分析</h2><p><img src="https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%97%B6%E7%A9%BA%E5%88%86%E6%9E%90.png" alt></p><p><strong><em>注意：一个序列基本有序用快速排序反而是不合适的！</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;本文章主要讲解快速排序的原理以及代码实现。&lt;/p&gt;
&lt;h2 id=&quot;快速排序基于的思想（分治法）&quot;&gt;&lt;a href=&quot;#快速排序基于的思想（分治法）&quot; class=&quot;headerlink&quot; title=&quot;快速排序基于的思想（分治法）&quot;&gt;&lt;/a&gt;快速排序基于的思想（分治法）&lt;/h2&gt;&lt;h3 id=&quot;分治法的简述&quot;&gt;&lt;a href=&quot;#分治法的简述&quot; class=&quot;headerlink&quot; title=&quot;分治法的简述&quot;&gt;&lt;/a&gt;分治法的简述&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;分治法是指将一个难以直接解决的大问题，划分成一些规模较小的子问题，以便各个击破，分而治之。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/%E5%88%86%E6%B2%BB%E6%B3%95%E5%8E%9F%E7%90%86%E5%9B%BE.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://YoHope99.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="快速排序" scheme="http://YoHope99.github.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
      <category term="分治法" scheme="http://YoHope99.github.io/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程单例模式</title>
    <link href="http://YoHope99.github.io/2019/07/06/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://YoHope99.github.io/2019/07/06/Java多线程单例模式/</id>
    <published>2019-07-06T01:04:00.000Z</published>
    <updated>2019-07-25T06:07:00.242Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇文章主要讲述基于Java语言实现多线程的单例模式。</p><h2 id="单例模式的概述"><a href="#单例模式的概述" class="headerlink" title="单例模式的概述"></a>单例模式的概述</h2><h3 id="为什么需要单例模式"><a href="#为什么需要单例模式" class="headerlink" title="为什么需要单例模式"></a>为什么需要单例模式</h3><p>&emsp;&emsp;&emsp;对于一个软件系统中的某些类而言，只有一个实例很重要，例如一个系统只能有一个窗口管理器或文件系统，一个系统只能有一个集市工具或ID生成器等等。在Windows操作系统中就只能打开一个任务管理器窗口，如下图1所示。如果不使用机智对窗口对象进行唯一化，势必会弹出多个窗口。如果这些窗口显示的内容完全一致，则是重复对象，浪费内存资源；如果这些窗口显示的内容不一致，则意味着在某一瞬间系统有多个状态，与实际不符合，这会给用户带来误解，不知道哪一个才是真实的状态。因此有时确保系统中某个对象的唯一性（即一个类只能有一个实例）非常重要。</p><p><img src="https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/Windows%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8.png" alt></p><a id="more"></a><h3 id="单例模式的定义"><a href="#单例模式的定义" class="headerlink" title="单例模式的定义"></a>单例模式的定义</h3><p>&emsp;&emsp;&emsp;确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。</p><h2 id="多线程单例模式的实现"><a href="#多线程单例模式的实现" class="headerlink" title="多线程单例模式的实现"></a>多线程单例模式的实现</h2><h3 id="基于饿汉式单例"><a href="#基于饿汉式单例" class="headerlink" title="基于饿汉式单例"></a>基于饿汉式单例</h3><p><strong>实例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Singleton s1, s2;</span><br><span class="line">s1 = Singleton.getInstance();</span><br><span class="line">s2 = Singleton.getInstance();</span><br><span class="line"><span class="keyword">if</span>(s1 == s2)&#123;</span><br><span class="line">System.out.println(<span class="string">"两个对象是相同实例"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"两个对象是不同实例"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行截图如下图2</strong></p><p><img src="https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B.png" alt></p><h3 id="基于懒汉式单例"><a href="#基于懒汉式单例" class="headerlink" title="基于懒汉式单例"></a>基于懒汉式单例</h3><p><strong>实例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//静态内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHandler</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> SingletonHandler.instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Singleton s1, s2;</span><br><span class="line">s1 = Singleton.getInstance();</span><br><span class="line">s2 = Singleton.getInstance();</span><br><span class="line">System.out.println(<span class="string">"两个对象实例是否相同？"</span>);</span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行截图如下图3</strong></p><p><img src="https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B.png" alt></p><h2 id="饿汉式与懒汉式的比较"><a href="#饿汉式与懒汉式的比较" class="headerlink" title="饿汉式与懒汉式的比较"></a>饿汉式与懒汉式的比较</h2><p>&emsp;&emsp;&emsp;饿汉式单例类在类加载时就将自己实例化，它的优点在于无需考虑多个线程同时访问的问题，可以确保实例的唯一性；从调用速度和反应时间速度来讲，由于单例对象一开始就得以创建，因此要优于懒汉式单例。但是无论系统在运行时是否需要使用该单例对象，由于在类加载时该对象就需要创建，因此从资源利用效率角度来讲饿汉式单例不及懒汉式单例，而且在系统加载时由于需要创建饿汉式单例对象，加载时间可能会比较长。</p><p>&emsp;&emsp;&emsp;懒汉式单例类在第一次使用时创建，无须一直占用系统资源，实现了延迟加载，但是必须要处理多个线程同时访问的问题，特别是当单例类作为资源控制器，在实例化时必然涉及资源初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的几率比较大，需要通过同步化机制进行控制。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><strong><em>单例模式的主要优点在于提供了对唯一实例的受控访问并可以节约系统资源；其主要缺点在于因为缺少抽象层而难以扩展，且单例类职责过重。</em></strong></p><hr><p><strong><em>单例模式适用情况包括：系统只需要一个实例对象；客户调用类的单个实例只允许使用一个公共访问点。</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这篇文章主要讲述基于Java语言实现多线程的单例模式。&lt;/p&gt;
&lt;h2 id=&quot;单例模式的概述&quot;&gt;&lt;a href=&quot;#单例模式的概述&quot; class=&quot;headerlink&quot; title=&quot;单例模式的概述&quot;&gt;&lt;/a&gt;单例模式的概述&lt;/h2&gt;&lt;h3 id=&quot;为什么需要单例模式&quot;&gt;&lt;a href=&quot;#为什么需要单例模式&quot; class=&quot;headerlink&quot; title=&quot;为什么需要单例模式&quot;&gt;&lt;/a&gt;为什么需要单例模式&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&amp;emsp;对于一个软件系统中的某些类而言，只有一个实例很重要，例如一个系统只能有一个窗口管理器或文件系统，一个系统只能有一个集市工具或ID生成器等等。在Windows操作系统中就只能打开一个任务管理器窗口，如下图1所示。如果不使用机智对窗口对象进行唯一化，势必会弹出多个窗口。如果这些窗口显示的内容完全一致，则是重复对象，浪费内存资源；如果这些窗口显示的内容不一致，则意味着在某一瞬间系统有多个状态，与实际不符合，这会给用户带来误解，不知道哪一个才是真实的状态。因此有时确保系统中某个对象的唯一性（即一个类只能有一个实例）非常重要。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/Windows%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://YoHope99.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="多线程" scheme="http://YoHope99.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://YoHope99.github.io/tags/Java/"/>
    
      <category term="单例模式" scheme="http://YoHope99.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>浅谈设计模式</title>
    <link href="http://YoHope99.github.io/2019/07/03/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://YoHope99.github.io/2019/07/03/浅谈设计模式/</id>
    <published>2019-07-03T01:18:03.000Z</published>
    <updated>2019-07-25T06:20:21.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在这篇文章中，我主要讲述以下内容：</p><ul><li>引言</li><li>设计模式的诞生与发展</li><li>设计模式的定义与GoF23种设计模式</li><li>设计模式的优点</li></ul><a id="more"></a><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h3 id="从两个实例说起："><a href="#从两个实例说起：" class="headerlink" title="从两个实例说起："></a>从两个实例说起：</h3><h4 id="1-实例一"><a href="#1-实例一" class="headerlink" title="1. 实例一"></a>1. 实例一</h4><p><strong>实例说明</strong></p><p>某软件公司要开发一个跨平台图像浏览系统，要求该系统能够显示BMP、JPG、GIF、PNG等多种格式的文件，<br>并且能够在Windows、Linux、Unix等多个操作系统上运行。系统首先将各种格式的文件解析为像素矩阵(Matrix)，然后将像素矩阵显示在屏幕上，在不同的操作系统中可以调用不同的绘制函数来绘制像素矩阵。</p><p><strong>设计方案</strong></p><p><img src="https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/%E5%AE%9E%E4%BE%8B1.png" alt></p><p><strong>问题</strong></p><ul><li>采用了多层继承结构，导致系统中类的个数急剧增加，具体层的类的个数 =所支持的图像文件格式数×所支持的操作系统数；</li><li>系统扩展麻烦，无论是增加新的图像文件格式还是增加新的操作系统，都需要增加大量的具体类，这将导致系统变得非常庞大，增加运行和维护开销。</li></ul><h4 id="2-实例二"><a href="#2-实例二" class="headerlink" title="2. 实例二"></a>2. 实例二</h4><p><strong>实例说明</strong></p><p>•某软件公司为某电影院开发了一套影院售票系统，在该系统中需要为不同类型的用户提供不同的电影票打折方式，具体打折方案如下：</p><p>(1)学生凭学生证可享受票价8折优惠；</p><p>(2)年龄在10周岁及以下的儿童可享受每张票减免10元的优惠（原始票价需大于等于20元）；</p><p>(3)影院VIP用户除享受票价半价优惠外还可进行积分，积分累计到一定额度可换取电影院赠送的奖品。</p><p><strong><em>注意：该系统在将来可能还要根据需要引入新的打折方式。</em></strong></p><p><strong>设计方案</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieTicket</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//compute the price</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//student ticket</span></span><br><span class="line">        <span class="keyword">if</span>(type.equalsIgnoreCase(<span class="string">"student"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.price * <span class="number">0.8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//children ticket</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type.equalsIgnoreCase(<span class="string">"children"</span>) &amp;&amp; <span class="keyword">this</span>.price &gt;= <span class="number">20</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.price - <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//VIP ticket</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type.equalsIgnoreCase(<span class="string">"vip"</span>)) &#123;</span><br><span class="line">            <span class="comment">//add points, code is omitted</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.price * <span class="number">0.5</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.price; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题</strong></p><p>(1) MovieTicket类的calculate()方法非常庞大，它包含各种打折算法的实现代码，在代码中出现了较长的条件转移语句，不利于测试和维护；</p><p>(2) 在增加新的打折算法或者对原有打折算法进行修改时必须修改MovieTicket类的源代码，系统的灵活性和可扩展性较差；</p><p>(3)算法的复用性差，如果另一个系统需要重用某些打折算法，只能通过对源代码进行复制粘贴来重用，无法单独重用其中的某个或某些算法。</p><h2 id="设计模式的诞生与发展"><a href="#设计模式的诞生与发展" class="headerlink" title="设计模式的诞生与发展"></a>设计模式的诞生与发展</h2><h3 id="设计模式的诞生"><a href="#设计模式的诞生" class="headerlink" title="设计模式的诞生"></a>设计模式的诞生</h3><ul><li>设计模式起源于建筑业而非软件业</li><li>设计模式之父——美国加利佛尼亚大学环境结构中心研究所所长ChristopherAlexander博士</li><li>《APattern Language: Towns, Buildings, Construction》——253个建筑和城市规划模式</li></ul><h3 id="设计模式的发展"><a href="#设计模式的发展" class="headerlink" title="设计模式的发展"></a>设计模式的发展</h3><ul><li>20世纪80年代末，软件工程界开始关注ChristopherAlexander等在这一住宅、公共建筑与城市规划领域的重大突破；</li><li>“四人组(Gang of Four，GoF，分别是Erich Gamma, Richard Helm, Ralph Johnson和John Vlissides)”于1994年归纳发表了23种在软件开发中使用频率较高的设计模式，旨在用模式来统一沟通面向对象方法在分析、设计和实现间的鸿沟。</li></ul><h2 id="设计模式的定义与GoF23种设计模式"><a href="#设计模式的定义与GoF23种设计模式" class="headerlink" title="设计模式的定义与GoF23种设计模式"></a>设计模式的定义与GoF23种设计模式</h2><h3 id="设计模式的定义"><a href="#设计模式的定义" class="headerlink" title="设计模式的定义"></a>设计模式的定义</h3><p><strong>Alexander给出了关于模式的经典定义：</strong></p><p>&emsp;&emsp;&emsp;每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，通过这种方式，人们可以无数次地重用那些已有的解决方案，无须再重复相同的工作。</p><p><strong>通俗理解：</strong>模式是<strong>在特定环境下</strong>人们解决某类重复出现<strong>问题</strong>的一套成功或有效的<strong>解决方案</strong>。</p><h3 id="GoF23种设计模式"><a href="#GoF23种设计模式" class="headerlink" title="GoF23种设计模式"></a>GoF23种设计模式</h3><p><img src="https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB.png" alt></p><p><strong><em>备注：创建型模式主要是用于创建对象，结构性模式主要用于处理类或对象的组合，行为型模式主要用于描述类或对象怎样交互和怎样分配职责</em></strong></p><h2 id="设计模式的优点"><a href="#设计模式的优点" class="headerlink" title="设计模式的优点"></a>设计模式的优点</h2><ul><li>融合了众多专家的经验，并以一种标准的形式供广大开发人员所用；</li><li>提供了一套通用的设计词汇和一种通用的语言，以方便开发人员之间进行沟通和交流，使得设计方案更加通俗易懂；</li><li>让人们可以更加简单方便地复用成功的设计和体系结构；</li><li>使得设计方案更加灵活，且易于修改；</li><li>将提高软件系统的开发效率和软件质量，且在一定程度上节约设计成本；</li><li>有助于初学者更深入地理解面向对象思想，方便阅读和学习现有类库与其他系统中的源代码，还可以提高软件的设计水平和代码质量。</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>&emsp;&emsp;&emsp;本文只是对设计模式进行了一个概述，具体常用的23种设计模式需要读者业余时间慢慢学习，同时需要知道的是在将来的软件设计与开发中使用设计模式，是一个成功的软件工程师必备的技能，这也正是我们学习设计模式的目的。</p><p><strong>参考资料：Java设计模式——刘伟编著</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在这篇文章中，我主要讲述以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;引言&lt;/li&gt;
&lt;li&gt;设计模式的诞生与发展&lt;/li&gt;
&lt;li&gt;设计模式的定义与GoF23种设计模式&lt;/li&gt;
&lt;li&gt;设计模式的优点&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://YoHope99.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://YoHope99.github.io/tags/Java/"/>
    
      <category term="设计模式" scheme="http://YoHope99.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java开发环境搭建</title>
    <link href="http://YoHope99.github.io/2019/07/02/Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://YoHope99.github.io/2019/07/02/Java开发环境搭建/</id>
    <published>2019-07-02T01:19:49.000Z</published>
    <updated>2019-07-25T06:03:57.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JDK的安装与配置"><a href="#JDK的安装与配置" class="headerlink" title="JDK的安装与配置"></a>JDK的安装与配置</h2><h3 id="1-获取JDK开发工具包"><a href="#1-获取JDK开发工具包" class="headerlink" title="1.获取JDK开发工具包"></a>1.获取JDK开发工具包</h3><p>（1）打开任意一款浏览器，到<a href="https://www.oracle.com/technetwork/cn/java/index.html" target="_blank" rel="noopener">Java官网</a>，打开Java官网主页，单击右上方的“ Java下载 ”项，进入最新的J2SE JDK下载页面；</p><p>（2）单击“ jdk-11.0.3_windows-x64_bin.exe ”文件名，即可下载 jdk-11.0.3_windows-x64_bin.exe可执行文件。</p><p><img src="https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/jdk.png" alt></p><a id="more"></a><h3 id="2-安装JDK"><a href="#2-安装JDK" class="headerlink" title="2.安装JDK"></a>2.安装JDK</h3><p>&emsp;&emsp;&emsp;找到下载的JDK文件jdk-11.0.3_windows-x64_bin.exe即可安装（由于我之前已经安装了，在这里我就不再描述），需要注意的是<strong>在安装过程中安装路径可以默认也可以自定义路径以及安装组件的全部安装还是选择部分安装</strong>（建议组件全部安装，避免后面出现不必要的麻烦），JDK类库安装完成后，会提示安装JRE环境，点击【更改】按钮可以更改JRE的安装路径，点击【下一步】进入JRE的安装。</p><h3 id="3-配置JDK"><a href="#3-配置JDK" class="headerlink" title="3.配置JDK"></a>3.配置JDK</h3><p>&emsp;&emsp;&emsp;安装JDK后，需要设置JAVA_Home、CLASSPATH以及PATH值<strong><em>（注意是在环境变量操作，而不是用户变量）</em></strong>。JDK具体配置步骤如下：</p><p>（1）在Windows桌面上右击【我的电脑】图标，在弹出菜单中选择【属性】命令，打开【系统属性】对话框。</p><p>（2）在【系统属性】对话框中选择【高级】选项卡，如图①所示，点击【环境变量按钮】，打开【环境变量】对话框，如图②所示。</p><p>  <img src="https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/%E7%B3%BB%E7%BB%9F%E5%B1%9E%E6%80%A7.png" alt><br>  <img src="https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png" alt></p><p>（3）在【环境变量】对话框的【系统变量】选项区域中，单击【新建】按钮，在【变量名】文本框中输入“ JAVA_HOME ”，在【变量值】文本框中输入“ C:\Program Files\Java\jdk1.8.0_121 ”（这个值是你安装JDK的路径），单击确定完成，如图③所示。</p><p>  <img src="https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/JAVA_HOME.png" alt></p><p>(4)在【环境变量】对话框的【系统变量】选项区域中，单击【新建】按钮，在【变量名】文本框中输入“ CLASSPATH ”，在【变量值】文本框中输入“ .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar ”，单击确定完成，如图④所示。</p><p><img src="https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/CLASSPATH.png" alt></p><p>（5）在【环境变量】对话框的【系统变量】选项区域中选中变量“ Path ”，单击【编辑】按钮，在弹出的【编辑系统环境变量】对话框中加入“ %JAVA_HOME%\bin;”(即JDK bin目录所在的路径，注意若该路径为Path的最后一项则不需要加“ ; ”)，我这里加在最前面，因为放在前面可以改变它的优先级，如图⑤所示。</p><p><img src="https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/Path.png" alt></p><p>（6）检测JDK是否配置成功，可以打开命令提示符窗口，输入“ javac ”命令，如果配置成功，会出现当前javac命令相关的参数说明，如图⑥所示。</p><p><img src="https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/test.png" alt></p><h2 id="知识延伸"><a href="#知识延伸" class="headerlink" title="知识延伸"></a>知识延伸</h2><p>（1）设置JAVA_HOME变量的作用是在其他变量中若要用到JDK的安装路径时，可用JAVA_HOME变量的值来替代换，使用时用%JAVA_HOME%表示。这样设置的优点是若改变了JDK的安装路径，只需要修改JAVA_HOME变量的值，而CLASSPATH及Path中的值不用修改。</p><p>（2）设置CLASSPATH主要用于说明JDK中所要用的类的位置，变量中的“ .; ”是不能省略的，“ . ”主要用于便是当前目录，而“ ; ”是各个部分的分隔符。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JDK的安装与配置&quot;&gt;&lt;a href=&quot;#JDK的安装与配置&quot; class=&quot;headerlink&quot; title=&quot;JDK的安装与配置&quot;&gt;&lt;/a&gt;JDK的安装与配置&lt;/h2&gt;&lt;h3 id=&quot;1-获取JDK开发工具包&quot;&gt;&lt;a href=&quot;#1-获取JDK开发工具包&quot; class=&quot;headerlink&quot; title=&quot;1.获取JDK开发工具包&quot;&gt;&lt;/a&gt;1.获取JDK开发工具包&lt;/h3&gt;&lt;p&gt;（1）打开任意一款浏览器，到&lt;a href=&quot;https://www.oracle.com/technetwork/cn/java/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java官网&lt;/a&gt;，打开Java官网主页，单击右上方的“ Java下载 ”项，进入最新的J2SE JDK下载页面；&lt;/p&gt;
&lt;p&gt;（2）单击“ jdk-11.0.3_windows-x64_bin.exe ”文件名，即可下载 jdk-11.0.3_windows-x64_bin.exe可执行文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yohope-1259678199.cos.ap-guangzhou.myqcloud.com/jdk.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://YoHope99.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://YoHope99.github.io/tags/Java/"/>
    
      <category term="环境配置" scheme="http://YoHope99.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
</feed>
