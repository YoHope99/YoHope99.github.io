<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring中Bean的装配方式</title>
      <link href="/2019/07/17/Spring%E4%B8%ADBean%E7%9A%84%E8%A3%85%E9%85%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2019/07/17/Spring%E4%B8%ADBean%E7%9A%84%E8%A3%85%E9%85%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>　　Bean的装配可以理解为依赖关系注入，Bean的装配方式即Bean依赖注入的方式。Spring容器支持多种形式的Bean的装配方式，如<strong>基于XML的装配、基于注解（Annotation）的装配和自动装配（其中最常用的是基于注解的装配）</strong>，本文章将主要讲解着三种装配方式的使用。</p><h2 id="基于XML的装配"><a href="#基于XML的装配" class="headerlink" title="基于XML的装配"></a>基于XML的装配</h2><h3 id="方式一：设置注入"><a href="#方式一：设置注入" class="headerlink" title="方式一：设置注入"></a>方式一：设置注入</h3><p>条件：①Bean类必须有一个无参构造方法；②Bean类必须为属性提供setter方法。</p><p><strong><em>在配置文件中，使用<property>元素来为每个属性注入值</property></em></strong></p><h3 id="方式二：构造注入"><a href="#方式二：构造注入" class="headerlink" title="方式二：构造注入"></a>方式二：构造注入</h3><p>条件：Bean类必须提供有参构造方法</p><p><strong><em>在配置文件中，使用<constructor-arg>元素来为参数注入值</constructor-arg></em></strong></p><h3 id="具体实现步骤如下"><a href="#具体实现步骤如下" class="headerlink" title="具体实现步骤如下"></a>具体实现步骤如下</h3><ol><li><p>创建Java类User，提供有参、无参构造方法以及属性setter方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ssm.assemble;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> Integer password;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.使用构造注入</span></span><br><span class="line"><span class="comment">     * 1.1提供带所有参数的有参构造方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, Integer password, List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2.使用设值注入</span></span><br><span class="line"><span class="comment">     * 2.1提供默认空参构造方法 ;</span></span><br><span class="line"><span class="comment">     * 2.2为所有属性提供setter方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(Integer password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setList</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User [username="</span> + username + <span class="string">", password="</span> + password +</span><br><span class="line">                <span class="string">", list="</span> + list + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Spring配置文件beans1.xml，使用以上两种方式装配Bean;</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string"> http://www.springframework.org/schema/beans/spring-beans-4.3.xsd"</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--1.使用构造注入方式装配User实例 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user1"</span> <span class="attr">class</span>=<span class="string">"com.ssm.assemble.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"小红"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"987654"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>"constructorvalue1"<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>"constructorvalue2"<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--2.使用设值注入方式装配User实例 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user2"</span> <span class="attr">class</span>=<span class="string">"com.ssm.assemble.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"小明"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入list集合 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>"setlistvalue1"<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>"setlistvalue2"<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建测试类XmlBeanAssembleTest，测试程序；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.ssm.assemble;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">public class XmlBeanAssembleTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 定义配置文件路径</span><br><span class="line">        String xmlPath = &quot;beans1.xml&quot;;</span><br><span class="line">        // 加载配置文件</span><br><span class="line">        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath);</span><br><span class="line">        // 构造方式输出结果</span><br><span class="line">        System.out.println(applicationContext.getBean(&quot;user1&quot;));</span><br><span class="line">        // 设值方式输出结果</span><br><span class="line">        System.out.println(applicationContext.getBean(&quot;user2&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>运行效果。</p><p><img src="http://pu0f1yxo8.bkt.clouddn.com/XML%E6%96%B9%E5%BC%8F%E7%BB%84%E8%A3%85Bean.png" alt></p></li></ol><h2 id="基于注解的装配"><a href="#基于注解的装配" class="headerlink" title="基于注解的装配"></a>基于注解的装配</h2><p>　　由于基于XML的装配可能会导致XML配置文件过于臃肿，给后续的维护和升级带来一定的困难。因此，Spring提供了对Annotation（注解）技术的全面支持。</p><p><img src="http://pu0f1yxo8.bkt.clouddn.com/%E4%B8%BB%E8%A6%81%E6%B3%A8%E8%A7%A3.png" alt></p><h3 id="具体实现步骤如下-1"><a href="#具体实现步骤如下-1" class="headerlink" title="具体实现步骤如下"></a>具体实现步骤如下</h3><ol><li><p>创建数据访问（Dao）层接口UserDao；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ssm.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建数据访问（UserDao）层接口的实现类UserDaoImpl，并且在实现类前添加对应的注解@Repository(“userDao”)；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ssm.annotation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span>(<span class="string">"userDao"</span>)</span><br><span class="line"><span class="comment">//@Repository("userDao")相当于配置文件中的:&lt;bean id="userDao" class="com.ssm.annotation.UserDaoImpl" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"userdao...save..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建业务（Service）层接口UserService；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ssm.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建业务（Service）层接口的实现类UserServiceImpl并添加属性对象UserDao的setter方法，并在实现类前添加对应的注解@Service(“userService”)和在类里面方法前添加对应的注解 @Resource(name=”userDao”)；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ssm.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"userService"</span>)</span><br><span class="line"><span class="comment">//相当于配置文件中的:&lt;bean id="userService" class="com.ssm.annotation.UserServiceImpl" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"userDao"</span>)</span><br><span class="line">    <span class="comment">//当于配置文件中的:&lt;property name="userDao"  ref="userDao"/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用userDao中的save方法</span></span><br><span class="line">        <span class="keyword">this</span>.userDao.save();</span><br><span class="line">        System.out.println(<span class="string">"userservice....save..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建控制（Controller）层Java类UserController，并在实现类前添加对应的注解@Controller(“userController”)和在类里面方法前添加对应的注解 @Resource(name=”userService”)；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.ssm.annotation;</span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line"></span><br><span class="line">@Controller(&quot;userController&quot;)</span><br><span class="line">//相当于配置文件中的:&lt;bean id=&quot;userController&quot; class=&quot;com.ssm.annotation.UserController&quot; /&gt;</span><br><span class="line"></span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @Resource(name=&quot;userService&quot;)</span><br><span class="line">    //当于配置文件中的:&lt;property name=&quot;userService&quot;  ref=&quot;userService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    private UserService userService;</span><br><span class="line">    public void save()&#123;</span><br><span class="line">        this.userService.save();</span><br><span class="line">        System.out.println(&quot;userController...save...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUserService(UserService userService) &#123;</span><br><span class="line">        this.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li><p>创建Spring配置文件beans2.xml，开启注解和定义Bean;</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">      http://www.springframework.org/schema/beans/spring-beans-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">      http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">  http://www.springframework.org/schema/context/spring-context-4.3.xsd"</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 使用 context 命名空间 ,在配置文件中开启相应的注解处理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--分别定义3个Bean实例  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"com.ssm.annotation.UserDaoImpl"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.ssm.annotation.UserServiceImpl"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userController"</span> <span class="attr">class</span>=<span class="string">"com.ssm.annotation.UserController"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用 context 命名空间 ,通知Spring扫描指定包下所有Bean类，进行注解解析--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.ssm.annotation"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="7"><li><p>创建测试类AnnotationAssembleTest，测试程序；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ssm.annotation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationAssembleTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义配置文件路径</span></span><br><span class="line">        String xmlPath = <span class="string">"beans2.xml"</span>;</span><br><span class="line">        <span class="comment">// 加载配置文件</span></span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(xmlPath);</span><br><span class="line">        <span class="comment">// 获取UserController实例</span></span><br><span class="line">        UserController userController = (UserController) applicationContext.getBean(<span class="string">"userController"</span>);</span><br><span class="line">        <span class="comment">// 调用UserController中的save()方法</span></span><br><span class="line">        userController.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行效果。</p><p><img src="http://pu0f1yxo8.bkt.clouddn.com/%E6%B3%A8%E8%A7%A3%E8%A3%85%E9%85%8D.png" alt></p></li></ol><h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p>　　所谓自动装配，就是将一个Bean自动的注入到到其他Bean的Property中。 Spring的<bean>元素中包含一个autowire属性，我们可以通过设置autowire的属性值来自动装配Bean。autowire属性有5个值，其值及说明下表所示：</bean></p><p><img src="http://pu0f1yxo8.bkt.clouddn.com/autowire%E5%B1%9E%E6%80%A7.png" alt></p><h3 id="具体实现步骤如下-2"><a href="#具体实现步骤如下-2" class="headerlink" title="具体实现步骤如下"></a>具体实现步骤如下</h3><p>这里只需要在基于注解的装配配置文件（beans.xml）中把注解方式换成自动装配即可，具体代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">      http://www.springframework.org/schema/beans/spring-beans-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">      http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">  http://www.springframework.org/schema/context/spring-context-4.3.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用 context 命名空间 ,在配置文件中开启相应的注解处理器 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;context:annotation-config /&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&amp;lt;!&amp;ndash;分别定义3个Bean实例  &amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;bean id="userDao" class="com.ssm.annotation.UserDaoImpl" /&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;bean id="userService" class="com.ssm.annotation.UserServiceImpl" /&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;bean id="userController" class="com.ssm.annotation.UserController" /&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&amp;lt;!&amp;ndash;使用 context 命名空间 ,通知Spring扫描指定包下所有Bean类，进行注解解析&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;context:component-scan base-package="com.ssm.annotation" /&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用bean元素的autowire属性完成自动装配 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"com.ssm.annotation.UserDaoImpl"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"com.ssm.annotation.UserServiceImpl"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userController"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"com.ssm.annotation.UserController"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>运行效果和基于注解的装配一样</strong></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>　　以上就是Spring中Bean的三种装配方式，其中我们需要重点掌握第二种基于注解的装配，它是我们日常工作最常用的一种装配。</p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Bean的装配方式 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈快速排序</title>
      <link href="/2019/07/13/%E8%B0%88%E8%B0%88%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/07/13/%E8%B0%88%E8%B0%88%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;&nbsp;&nbsp;本文章主要讲解快速排序的原理以及代码实现。</p><h2 id="快速排序基于的思想（分治法）"><a href="#快速排序基于的思想（分治法）" class="headerlink" title="快速排序基于的思想（分治法）"></a>快速排序基于的思想（分治法）</h2><h3 id="分治法的简述"><a href="#分治法的简述" class="headerlink" title="分治法的简述"></a>分治法的简述</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;分治法是指将一个难以直接解决的大问题，划分成一些规模较小的子问题，以便各个击破，分而治之。</p><p><img src="http://pu0f1yxo8.bkt.clouddn.com/%E5%88%86%E6%B2%BB%E6%B3%95%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt></p><a id="more"></a><h3 id="分治法的求解过程"><a href="#分治法的求解过程" class="headerlink" title="分治法的求解过程"></a>分治法的求解过程</h3><p><strong>分治法求解问题的主要步骤：划分，求解，合并。</strong></p><p>（1）问题划分。将规模为n的问题划分成k个子问题；</p><p>（2）求解子问题。各子问题的求解方法相同，通常采用递归方法实现；</p><p>（3）合并子问题的解。将各子问题的解逐层合并，得到问题的最终解。</p><h2 id="快速排序的分治策略"><a href="#快速排序的分治策略" class="headerlink" title="快速排序的分治策略"></a>快速排序的分治策略</h2><p>（1）划分：选定一个记录作为轴值，以轴值为基准将整个序列划分为两个子序列r1… ri-1和ri+1 … rn，前一个子    序列中记录的值均小于或等于轴值，后一个子序列中记录的值均大于或等于轴值；</p><p>（2）求解子问题：分别对划分后的每一个子序列递归处理；</p><p>（3）合并：由于对子序列r1 … ri-1和ri+1 … rn的排序是就地进行的，所以合并不需要执行任何操作。</p><p><img src="http://pu0f1yxo8.bkt.clouddn.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png" alt></p><h2 id="举例子说明"><a href="#举例子说明" class="headerlink" title="举例子说明"></a>举例子说明</h2><p><strong>对序列[23,13,35,6,19,50,28]进行快速排序的过程。（注意：这里以第一个记录作为轴值，黑体代表轴值）</strong></p><p>一次划分过程，如下图：</p><p><img src="http://pu0f1yxo8.bkt.clouddn.com/%E5%88%92%E5%88%86%E8%BF%87%E7%A8%8B.jpg" alt></p><p>以轴值为基准将待排序序列划分为两个子序列后，对每一个子序列分别递归进行处理，下图是一个快速排序的完整的例子。</p><p><img src="http://pu0f1yxo8.bkt.clouddn.com/%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.jpg" alt></p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> r[ ], <span class="keyword">int</span> first, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i=first, j=end;         <span class="comment">//初始化</span></span><br><span class="line">      <span class="keyword">int</span> temp;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">while</span> (i&lt;j)</span><br><span class="line">       &#123;  </span><br><span class="line">           <span class="keyword">while</span> (i&lt;j &amp;&amp; r[i]&lt;= r[j]) </span><br><span class="line">               j--;        <span class="comment">//右侧扫描</span></span><br><span class="line">           <span class="keyword">if</span> (i&lt;j) &#123; </span><br><span class="line">               temp=r[i]; r[i]=r[j]; r[j]=temp;   <span class="comment">//将较小记录交换到前面</span></span><br><span class="line">               i++; </span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">while</span> (i&lt;j &amp;&amp; r[i]&lt;= r[j]) </span><br><span class="line">               i++;     <span class="comment">//左侧扫描 </span></span><br><span class="line">               <span class="keyword">if</span> (i&lt;j) &#123;</span><br><span class="line">                  temp=r[i]; r[i]=r[j]; r[j]=temp;   <span class="comment">//将较大记录交换到后面</span></span><br><span class="line">                  j--; </span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">      <span class="keyword">return</span> i;      <span class="comment">// i为轴值记录的最终位置</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> r[ ], <span class="keyword">int</span> first, <span class="keyword">int</span> end)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="keyword">int</span> mid; <span class="comment">//划分后的轴值位置</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">if</span> (first &lt; end) &#123;      </span><br><span class="line">     mid = Partition(r, first, end);     <span class="comment">//划分，mid是轴值在序列中的位置</span></span><br><span class="line">     QuickSort(r, first, mid<span class="number">-1</span>);        <span class="comment">//求解子问题1，对左侧子序列进行快速排序</span></span><br><span class="line">     QuickSort(r, mid+<span class="number">1</span>, end);          <span class="comment">//求解子问题2，对右侧子序列进行快速排序</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序时间复杂度和空间复杂度分析"><a href="#快速排序时间复杂度和空间复杂度分析" class="headerlink" title="快速排序时间复杂度和空间复杂度分析"></a>快速排序时间复杂度和空间复杂度分析</h2><p><img src="http://pu0f1yxo8.bkt.clouddn.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%97%B6%E7%A9%BA%E5%88%86%E6%9E%90.png" alt></p><p><strong><em>注意：一个序列基本有序用快速排序反而是不合适的！</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速排序 </tag>
            
            <tag> 分治法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程单例模式</title>
      <link href="/2019/07/06/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/07/06/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇文章主要讲述基于Java语言实现多线程的单例模式。</p><h2 id="单例模式的概述"><a href="#单例模式的概述" class="headerlink" title="单例模式的概述"></a>单例模式的概述</h2><h3 id="为什么需要单例模式"><a href="#为什么需要单例模式" class="headerlink" title="为什么需要单例模式"></a>为什么需要单例模式</h3><p>&emsp;&emsp;&emsp;对于一个软件系统中的某些类而言，只有一个实例很重要，例如一个系统只能有一个窗口管理器或文件系统，一个系统只能有一个集市工具或ID生成器等等。在Windows操作系统中就只能打开一个任务管理器窗口，如下图1所示。如果不使用机智对窗口对象进行唯一化，势必会弹出多个窗口。如果这些窗口显示的内容完全一致，则是重复对象，浪费内存资源；如果这些窗口显示的内容不一致，则意味着在某一瞬间系统有多个状态，与实际不符合，这会给用户带来误解，不知道哪一个才是真实的状态。因此有时确保系统中某个对象的唯一性（即一个类只能有一个实例）非常重要。</p><p><img src="http://pu0f1yxo8.bkt.clouddn.com/Windows%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8.png" alt></p><a id="more"></a><h3 id="单例模式的定义"><a href="#单例模式的定义" class="headerlink" title="单例模式的定义"></a>单例模式的定义</h3><p>&emsp;&emsp;&emsp;确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。</p><h2 id="多线程单例模式的实现"><a href="#多线程单例模式的实现" class="headerlink" title="多线程单例模式的实现"></a>多线程单例模式的实现</h2><h3 id="基于饿汉式单例"><a href="#基于饿汉式单例" class="headerlink" title="基于饿汉式单例"></a>基于饿汉式单例</h3><p><strong>实例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Singleton s1, s2;</span><br><span class="line">s1 = Singleton.getInstance();</span><br><span class="line">s2 = Singleton.getInstance();</span><br><span class="line"><span class="keyword">if</span>(s1 == s2)&#123;</span><br><span class="line">System.out.println(<span class="string">"两个对象是相同实例"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"两个对象是不同实例"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行截图如下图2</strong></p><p><img src="http://pu0f1yxo8.bkt.clouddn.com/%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B.png" alt></p><h3 id="基于懒汉式单例"><a href="#基于懒汉式单例" class="headerlink" title="基于懒汉式单例"></a>基于懒汉式单例</h3><p><strong>实例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//静态内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHandler</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> SingletonHandler.instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Singleton s1, s2;</span><br><span class="line">s1 = Singleton.getInstance();</span><br><span class="line">s2 = Singleton.getInstance();</span><br><span class="line">System.out.println(<span class="string">"两个对象实例是否相同？"</span>);</span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行截图如下图3</strong></p><p><img src="http://pu0f1yxo8.bkt.clouddn.com/%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B.png" alt></p><h2 id="饿汉式与懒汉式的比较"><a href="#饿汉式与懒汉式的比较" class="headerlink" title="饿汉式与懒汉式的比较"></a>饿汉式与懒汉式的比较</h2><p>&emsp;&emsp;&emsp;饿汉式单例类在类加载时就将自己实例化，它的优点在于无需考虑多个线程同时访问的问题，可以确保实例的唯一性；从调用速度和反应时间速度来讲，由于单例对象一开始就得以创建，因此要优于懒汉式单例。但是无论系统在运行时是否需要使用该单例对象，由于在类加载时该对象就需要创建，因此从资源利用效率角度来讲饿汉式单例不及懒汉式单例，而且在系统加载时由于需要创建饿汉式单例对象，加载时间可能会比较长。</p><p>&emsp;&emsp;&emsp;懒汉式单例类在第一次使用时创建，无须一直占用系统资源，实现了延迟加载，但是必须要处理多个线程同时访问的问题，特别是当单例类作为资源控制器，在实例化时必然涉及资源初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的几率比较大，需要通过同步化机制进行控制。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><strong><em>单例模式的主要优点在于提供了对唯一实例的受控访问并可以节约系统资源；其主要缺点在于因为缺少抽象层而难以扩展，且单例类职责过重。</em></strong></p><hr><p><strong><em>单例模式适用情况包括：系统只需要一个实例对象；客户调用类的单个实例只允许使用一个公共访问点。</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 单例模式 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈设计模式</title>
      <link href="/2019/07/03/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/07/03/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在这篇文章中，我主要讲述以下内容：</p><ul><li>引言</li><li>设计模式的诞生与发展</li><li>设计模式的定义与GoF23种设计模式</li><li>设计模式的优点</li></ul><a id="more"></a><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h3 id="从两个实例说起："><a href="#从两个实例说起：" class="headerlink" title="从两个实例说起："></a>从两个实例说起：</h3><h4 id="1-实例一"><a href="#1-实例一" class="headerlink" title="1. 实例一"></a>1. 实例一</h4><p><strong>实例说明</strong></p><p>某软件公司要开发一个跨平台图像浏览系统，要求该系统能够显示BMP、JPG、GIF、PNG等多种格式的文件，<br>并且能够在Windows、Linux、Unix等多个操作系统上运行。系统首先将各种格式的文件解析为像素矩阵(Matrix)，然后将像素矩阵显示在屏幕上，在不同的操作系统中可以调用不同的绘制函数来绘制像素矩阵。</p><p><strong>设计方案</strong></p><p><img src="http://pu0f1yxo8.bkt.clouddn.com/%E5%AE%9E%E4%BE%8B1.png" alt></p><p><strong>问题</strong></p><ul><li>采用了多层继承结构，导致系统中类的个数急剧增加，具体层的类的个数 =所支持的图像文件格式数×所支持的操作系统数；</li><li>系统扩展麻烦，无论是增加新的图像文件格式还是增加新的操作系统，都需要增加大量的具体类，这将导致系统变得非常庞大，增加运行和维护开销。</li></ul><h4 id="2-实例二"><a href="#2-实例二" class="headerlink" title="2. 实例二"></a>2. 实例二</h4><p><strong>实例说明</strong></p><p>•某软件公司为某电影院开发了一套影院售票系统，在该系统中需要为不同类型的用户提供不同的电影票打折方式，具体打折方案如下：</p><p>(1)学生凭学生证可享受票价8折优惠；</p><p>(2)年龄在10周岁及以下的儿童可享受每张票减免10元的优惠（原始票价需大于等于20元）；</p><p>(3)影院VIP用户除享受票价半价优惠外还可进行积分，积分累计到一定额度可换取电影院赠送的奖品。</p><p><strong><em>注意：该系统在将来可能还要根据需要引入新的打折方式。</em></strong></p><p><strong>设计方案</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieTicket</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//compute the price</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//student ticket</span></span><br><span class="line">        <span class="keyword">if</span>(type.equalsIgnoreCase(<span class="string">"student"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.price * <span class="number">0.8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//children ticket</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type.equalsIgnoreCase(<span class="string">"children"</span>) &amp;&amp; <span class="keyword">this</span>.price &gt;= <span class="number">20</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.price - <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//VIP ticket</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type.equalsIgnoreCase(<span class="string">"vip"</span>)) &#123;</span><br><span class="line">            <span class="comment">//add points, code is omitted</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.price * <span class="number">0.5</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.price; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题</strong></p><p>(1) MovieTicket类的calculate()方法非常庞大，它包含各种打折算法的实现代码，在代码中出现了较长的条件转移语句，不利于测试和维护；</p><p>(2) 在增加新的打折算法或者对原有打折算法进行修改时必须修改MovieTicket类的源代码，系统的灵活性和可扩展性较差；</p><p>(3)算法的复用性差，如果另一个系统需要重用某些打折算法，只能通过对源代码进行复制粘贴来重用，无法单独重用其中的某个或某些算法。</p><h2 id="设计模式的诞生与发展"><a href="#设计模式的诞生与发展" class="headerlink" title="设计模式的诞生与发展"></a>设计模式的诞生与发展</h2><h3 id="设计模式的诞生"><a href="#设计模式的诞生" class="headerlink" title="设计模式的诞生"></a>设计模式的诞生</h3><ul><li>设计模式起源于建筑业而非软件业</li><li>设计模式之父——美国加利佛尼亚大学环境结构中心研究所所长ChristopherAlexander博士</li><li>《APattern Language: Towns, Buildings, Construction》——253个建筑和城市规划模式</li></ul><h3 id="设计模式的发展"><a href="#设计模式的发展" class="headerlink" title="设计模式的发展"></a>设计模式的发展</h3><ul><li>20世纪80年代末，软件工程界开始关注ChristopherAlexander等在这一住宅、公共建筑与城市规划领域的重大突破；</li><li>“四人组(Gang of Four，GoF，分别是Erich Gamma, Richard Helm, Ralph Johnson和John Vlissides)”于1994年归纳发表了23种在软件开发中使用频率较高的设计模式，旨在用模式来统一沟通面向对象方法在分析、设计和实现间的鸿沟。</li></ul><h2 id="设计模式的定义与GoF23种设计模式"><a href="#设计模式的定义与GoF23种设计模式" class="headerlink" title="设计模式的定义与GoF23种设计模式"></a>设计模式的定义与GoF23种设计模式</h2><h3 id="设计模式的定义"><a href="#设计模式的定义" class="headerlink" title="设计模式的定义"></a>设计模式的定义</h3><p><strong>Alexander给出了关于模式的经典定义：</strong></p><p>&emsp;&emsp;&emsp;每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，通过这种方式，人们可以无数次地重用那些已有的解决方案，无须再重复相同的工作。</p><p><strong>通俗理解：</strong>模式是<strong>在特定环境下</strong>人们解决某类重复出现<strong>问题</strong>的一套成功或有效的<strong>解决方案</strong>。</p><h3 id="GoF23种设计模式"><a href="#GoF23种设计模式" class="headerlink" title="GoF23种设计模式"></a>GoF23种设计模式</h3><p><img src="http://pu0f1yxo8.bkt.clouddn.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB.png" alt></p><p><strong><em>备注：创建型模式主要是用于创建对象，结构性模式主要用于处理类或对象的组合，行为型模式主要用于描述类或对象怎样交互和怎样分配职责</em></strong></p><h2 id="设计模式的优点"><a href="#设计模式的优点" class="headerlink" title="设计模式的优点"></a>设计模式的优点</h2><ul><li>融合了众多专家的经验，并以一种标准的形式供广大开发人员所用；</li><li>提供了一套通用的设计词汇和一种通用的语言，以方便开发人员之间进行沟通和交流，使得设计方案更加通俗易懂；</li><li>让人们可以更加简单方便地复用成功的设计和体系结构；</li><li>使得设计方案更加灵活，且易于修改；</li><li>将提高软件系统的开发效率和软件质量，且在一定程度上节约设计成本；</li><li>有助于初学者更深入地理解面向对象思想，方便阅读和学习现有类库与其他系统中的源代码，还可以提高软件的设计水平和代码质量。</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>&emsp;&emsp;&emsp;本文只是对设计模式进行了一个概述，具体常用的23种设计模式需要读者业余时间慢慢学习，同时需要知道的是在将来的软件设计与开发中使用设计模式，是一个成功的软件工程师必备的技能，这也正是我们学习设计模式的目的。</p><p><strong>参考资料：Java设计模式——刘伟编著</strong></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java开发环境搭建</title>
      <link href="/2019/07/02/Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/07/02/Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="JDK的安装与配置"><a href="#JDK的安装与配置" class="headerlink" title="JDK的安装与配置"></a>JDK的安装与配置</h2><h3 id="1-获取JDK开发工具包"><a href="#1-获取JDK开发工具包" class="headerlink" title="1.获取JDK开发工具包"></a>1.获取JDK开发工具包</h3><p>（1）打开任意一款浏览器，到<a href="https://www.oracle.com/technetwork/cn/java/index.html" target="_blank" rel="noopener">Java官网</a>，打开Java官网主页，单击右上方的“ Java下载 ”项，进入最新的J2SE JDK下载页面；</p><p>（2）单击“ jdk-11.0.3_windows-x64_bin.exe ”文件名，即可下载 jdk-11.0.3_windows-x64_bin.exe可执行文件。</p><p><img src="http://pu0f1yxo8.bkt.clouddn.com/jdk.png" alt></p><a id="more"></a><h3 id="2-安装JDK"><a href="#2-安装JDK" class="headerlink" title="2.安装JDK"></a>2.安装JDK</h3><p>&emsp;&emsp;&emsp;找到下载的JDK文件jdk-11.0.3_windows-x64_bin.exe即可安装（由于我之前已经安装了，在这里我就不再描述），需要注意的是<strong>在安装过程中安装路径可以默认也可以自定义路径以及安装组件的全部安装还是选择部分安装</strong>（建议组件全部安装，避免后面出现不必要的麻烦），JDK类库安装完成后，会提示安装JRE环境，点击【更改】按钮可以更改JRE的安装路径，点击【下一步】进入JRE的安装。</p><h3 id="3-配置JDK"><a href="#3-配置JDK" class="headerlink" title="3.配置JDK"></a>3.配置JDK</h3><p>&emsp;&emsp;&emsp;安装JDK后，需要设置JAVA_Home、CLASSPATH以及PATH值<strong><em>（注意是在环境变量操作，而不是用户变量）</em></strong>。JDK具体配置步骤如下：</p><p>（1）在Windows桌面上右击【我的电脑】图标，在弹出菜单中选择【属性】命令，打开【系统属性】对话框。</p><p>（2）在【系统属性】对话框中选择【高级】选项卡，如图①所示，点击【环境变量按钮】，打开【环境变量】对话框，如图②所示。</p><p>  <img src="http://pu0f1yxo8.bkt.clouddn.com/%E7%B3%BB%E7%BB%9F%E5%B1%9E%E6%80%A7.png" alt><br>  <img src="http://pu0f1yxo8.bkt.clouddn.com/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png" alt></p><p>（3）在【环境变量】对话框的【系统变量】选项区域中，单击【新建】按钮，在【变量名】文本框中输入“ JAVA_HOME ”，在【变量值】文本框中输入“ C:\Program Files\Java\jdk1.8.0_121 ”（这个值是你安装JDK的路径），单击确定完成，如图③所示。</p><p>  <img src="http://pu0f1yxo8.bkt.clouddn.com/JAVA_HOME.png" alt></p><p>(4)在【环境变量】对话框的【系统变量】选项区域中，单击【新建】按钮，在【变量名】文本框中输入“ CLASSPATH ”，在【变量值】文本框中输入“ .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar ”，单击确定完成，如图④所示。</p><p>  <img src="http://pu0f1yxo8.bkt.clouddn.com/CLASSPATH.png" alt></p><p>（5）在【环境变量】对话框的【系统变量】选项区域中选中变量“ Path ”，单击【编辑】按钮，在弹出的【编辑系统环境变量】对话框中加入“ %JAVA_HOME%\bin;”(即JDK bin目录所在的路径，注意若该路径为Path的最后一项则不需要加“ ; ”)，我这里加在最前面，因为放在前面可以改变它的优先级，如图⑤所示。</p><p>{  <img src="http://pu0f1yxo8.bkt.clouddn.com/Path.png" alt></p><p>（6）检测JDK是否配置成功，可以打开命令提示符窗口，输入“ javac ”命令，如果配置成功，会出现当前javac命令相关的参数说明，如图⑥所示。</p><p>  <img src="http://pu0f1yxo8.bkt.clouddn.com/test.png" alt></p><h2 id="知识延伸"><a href="#知识延伸" class="headerlink" title="知识延伸"></a>知识延伸</h2><p>（1）设置JAVA_HOME变量的作用是在其他变量中若要用到JDK的安装路径时，可用JAVA_HOME变量的值来替代换，使用时用%JAVA_HOME%表示。这样设置的优点是若改变了JDK的安装路径，只需要修改JAVA_HOME变量的值，而CLASSPATH及Path中的值不用修改。</p><p>（2）设置CLASSPATH主要用于说明JDK中所要用的类的位置，变量中的“ .; ”是不能省略的，“ . ”主要用于便是当前目录，而“ ; ”是各个部分的分隔符。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
